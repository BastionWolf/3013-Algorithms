<!DOCTYPE html>
<!-- saved from url=(0036)http://www.columbia.edu/~jxz2101/#82 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">kbd,.key{display:inline;display:inline-block;min-width:1em;padding:.2em .3em;font:normal 0.85em/1 "Lucida Grande",Lucida,Arial,sans-serif;text-align:center;text-decoration:none;-moz-border-radius:.3em;-webkit-border-radius:.3em;border-radius:.3em;border:none;cursor:default;-moz-user-select:none;-webkit-user-select:none;user-select:none;}kbd[title],.key[title]{cursor:help;}kbd,kbd.dark,.dark-keys kbd,.key,.key.dark,.dark-keys .key{background:#505050;background:-moz-linear-gradient(top, #3c3c3c, #505050);background:-webkit-gradient(linear, left top, left bottom, from(#3c3c3c), to(#505050));color:#fafafa;text-shadow:-1px -1px 0 #464646;-moz-box-shadow:inset 0 0 1px #969696,inset 0 -0.05em 0.4em #505050,0 0.1em 0 #1e1e1e,0 0.1em 0.1em rgba(0, 0, 0, 0.3);-webkit-box-shadow:inset 0 0 1px #969696,inset 0 -0.05em 0.4em #505050,0 0.1em 0 #1e1e1e,0 0.1em 0.1em rgba(0, 0, 0, 0.3);box-shadow:inset 0 0 1px #969696,inset 0 -0.05em 0.4em #505050,0 0.1em 0 #1e1e1e,0 0.1em 0.1em rgba(0, 0, 0, 0.3);}kbd.light,.light-keys kbd,.key.light,.light-keys .key{background:#fafafa;background:-moz-linear-gradient(top, #d2d2d2, #ffffff);background:-webkit-gradient(linear, left top, left bottom, from(#d2d2d2), to(#ffffff));color:#323232;text-shadow:0 0 2px #ffffff;-moz-box-shadow:inset 0 0 1px #ffffff,inset 0 0 0.4em #c8c8c8,0 0.1em 0 #828282,0 0.11em 0 rgba(0, 0, 0, 0.4),0 0.1em 0.11em rgba(0, 0, 0, 0.9);-webkit-box-shadow:inset 0 0 1px #ffffff,inset 0 0 0.4em #c8c8c8,0 0.1em 0 #828282,0 0.11em 0 rgba(0, 0, 0, 0.4),0 0.1em 0.11em rgba(0, 0, 0, 0.9);box-shadow:inset 0 0 1px #ffffff,inset 0 0 0.4em #c8c8c8,0 0.1em 0 #828282,0 0.11em 0 rgba(0, 0, 0, 0.4),0 0.1em 0.11em rgba(0, 0, 0, 0.9);}html,body{background:#d7d7d7;font-family:Georgia;font-size:20px;overflow:hidden;}#slideshow{background:#fff;overflow:hidden;position:absolute;-webkit-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top-left;-moz-box-shadow:0 0 30px #888;-webkit-box-shadow:0 0 30px #888;box-shadow:0 0 30px #888;}#slideshow .slide{height:100%;width:100%;}#slideshow .slide>.left{text-align:left;}#slideshow .slide>.center{text-align:center;}#slideshow .slide>.right{text-align:right;}#slideshow .slide>.top{vertical-align:top;}#slideshow .slide>.middle{vertical-align:middle;}#slideshow .slide>.bottom{vertical-align:bottom;}#slideshow .slide .content{background-position:center;background-repeat:no-repeat;display:table-cell;padding:1em 4em 1em 4em;}#slideshow .slide .content .left{display:block;text-align:left;}#slideshow .slide .content .center{display:block;text-align:center;}#slideshow .slide .content .right{display:block;text-align:right;}#slideshow .slide .content pre,#slideshow .slide .content code{font-family:Monaco, monospace;font-size:16px;}#slideshow .slide .content h1 code{font-size:0.8em;}#slideshow .overlay{bottom:0;top:0;right:0;left:0;opacity:0.95;background:#000;display:none;position:absolute;z-index:1000;}#slideshow .overlay .content{color:white;position:absolute;top:10%;bottom:10%;left:10%;height:10%;}#slideshow .overlay .content td{color:white;padding:10px;}#slideshow .overlay .content td:first-child{padding-left:0;}#slideshow .overlay .dismiss{top:85%;}#slideshow .position{bottom:12px;opacity:0.5;position:absolute;right:20px;}li>code,p>code{padding:1px 4px;}pre code{display:block;padding:0.5em;background:#F0F0F0;}pre code,pre .subst,pre .tag .title,pre .lisp .title,pre .clojure .built_in,pre .nginx .title{color:black;}pre .string,pre .title,pre .constant,pre .parent,pre .tag .value,pre .rules .value,pre .rules .value .number,pre .preprocessor,pre .ruby .symbol,pre .ruby .symbol .string,pre .aggregate,pre .template_tag,pre .django .variable,pre .smalltalk .class,pre .addition,pre .flow,pre .stream,pre .bash .variable,pre .apache .tag,pre .apache .cbracket,pre .tex .command,pre .tex .special,pre .erlang_repl .function_or_atom,pre .markdown .header{color:#800;}pre .comment,pre .annotation,pre .template_comment,pre .diff .header,pre .chunk,pre .markdown .blockquote{color:#888;}pre .number,pre .date,pre .regexp,pre .literal,pre .smalltalk .symbol,pre .smalltalk .char,pre .go .constant,pre .change,pre .markdown .bullet,pre .markdown .link_url{color:#080;}pre .label,pre .javadoc,pre .ruby .string,pre .decorator,pre .filter .argument,pre .localvars,pre .array,pre .attr_selector,pre .important,pre .pseudo,pre .pi,pre .doctype,pre .deletion,pre .envvar,pre .shebang,pre .apache .sqbracket,pre .nginx .built_in,pre .tex .formula,pre .erlang_repl .reserved,pre .input_number,pre .markdown .link_label,pre .vhdl .attribute,pre .clojure .attribute,pre .coffeescript .property{color:#8888ff;}pre .keyword,pre .id,pre .phpdoc,pre .title,pre .built_in,pre .aggregate,pre .css .tag,pre .javadoctag,pre .phpdoc,pre .yardoctag,pre .smalltalk .class,pre .winutils,pre .bash .variable,pre .apache .tag,pre .go .typename,pre .tex .command,pre .markdown .strong,pre .request,pre .status{font-weight:bold;}pre .markdown .emphasis{font-style:italic;}pre .nginx .built_in{font-weight:normal;}pre .coffeescript .javascript,pre .javascript .xml,pre .tex .formula,pre .xml .javascript,pre .xml .vbscript,pre .xml .css,pre .xml .cdata{opacity:0.5;}</style>
    <title>Data Structures for Interviews</title>
    
    <script src="./Data Structures for Interviews_files/remark-0.4.6.min.js" type="text/javascript">
    </script>
    <style type="text/css" media="screen">
      p {
        font-size: 1.4em;
      }
      table {
        margin: 0 auto;
        font-size: 1.6em;
      }
      img {
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <textarea id="source" style="display: none;">
class: center, middle

# Data Structures for Interviews

2014-10-22

Justin Zhao, ADI

Adapted from Zack Newman

adicu.com

---

# Expectations for this talk

I assume familiarity with Java (if you know some other language, you can probably
figure it out). I didn't check all of my code.

The is **not** a replacement for 3134. It should be a good preview that gets you
ready for some basic interviews.

PLEASE stop me if I say something that doesn't make sense.

&gt; He who asks is a fool for five minutes, but he who does not ask remains a fool forever.
&gt; .right[*Chinese Proverb*]

---

# Gameplan

* Review of Big O 

* Data Structures

* Sorting Algorithms

* Sample Interview Questions


---

# What Will Be Covered

* Functionality, operations, applicability of data structures

* Overview of important data structure algorithms and performance

* Sample interview questions and how to tackle them with data structures

---

# What Will Not Be Covered

* The answers to every interview question

* Best interview strategies (interview practice)

* Implementation details (3134)

&gt; It's probably good for you to understand details of implementation, but not necessary for most interviews

---

# Review of Big O

* "Big O" is the "asymptotic runtime"

* Expressed as function of the size of the inputs

* Consider best, worst, and average cases

![Big O](http://i.stack.imgur.com/WcBRI.png)

---

# Review of Big O

    /**
     * Return the index of the minimum element in an integer array.
     */
    public static int findMin(int[] array) {
        int minIndex = 0;
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i] &lt; array[minIndex]) {
                minIndex = i;
            }
        }
    }

---

# Review of Big O

    /**
     * Return the index of the minimum element in an integer array.
     */
    public static int findMin(int[] array) {
        int minIndex = 0; // O(1)
        for (int i = 0; i &lt; array.length; i++) { // n times
            if (array[i] &lt; array[minIndex]) { // O(1)
                minIndex = i; // O(1)
            }
        }
    } // O(1) + n (O(1) + O(1)) = O(1) + n O(1) = O(1) + O(n) = O(n)

---

# Review of Big O

    /**
     * Return the index of array (which must be sorted) at which value can be
     * found, or -1 if it is absent.
     */
    public static int find(int[] array, int value) {
        return findHelper(array, 0, array.length - 1, value);
    } // O(lg n)

    private static int findHelper(int[] array, int minIndex, int maxIndex,
            int value) {
        if (maxIndex &lt; minIndex) {
            return -1;
        }

        int index = (maxIndex + minIndex) / 2;
        if (value &lt; array[index]) {
            return findHelper(array, minIndex, index, value);
        } else if (value &gt; array[index]) {
            return findHelper(array, index + 1, maxIndex, value);
        } else {
            return index;
        }
    }

---

# Review of Big O

Which performance is better?

`O(10000 n)` vs. `O(n)`

`O(log n)` vs. `O(log(log n))`

`O(n log n)` vs. `O(n log k)`

`O(0.000001 n^2)` vs. `O(9999999 n^1.999999)`

`O(2^n)` vs. `O(3^n)`

`O(n!)` vs. `O(n^n)`

---

# Abstract Data Type (ADT)

* What is a "data structure" anyway? We define ADTs first

* An interface for interacting with data

* lists, stacks, sets, queues, maps, trees, priority queue etc.

* Defines operations and results, but not how they're implemented

---

# Data Structures

* Data Structure is an implementation of ADT

* For example, an "ArrayList" or "HashMap"

* Many ADTs can be implemented as the same Data Structure.

---

# Data Structure Primitives

## Arrays

      int[] array = {1, 3, 5, 2, 6, 9};

      /*
       * Index: 0 1 2 3 4 5
       * Value: 1 3 5 2 6 9
       */

---

# Data Structure Primitives

## Linked lists

![Linked List](http://upload.wikimedia.org/wikipedia/commons/1/1b/C_language_linked_list.png)

---

# Data Structure Primitives

## Linked lists

      // Attributes
      public class Node {
          public int value;
          public Node next;

          public Node(int value, Node next) {
              this.value = value;
              this.next = next;
          }
      }

      // Methods
      public interface MyList {
          public int get(int index);

          public void update(int index, int value);

          public void append(int value);

          public String toString();
      }

---

# List Performance

&lt;table&gt;
  &lt;th&gt;
    &lt;td&gt;Array&lt;/td&gt; &lt;td&gt;List&lt;/td&gt;
  &lt;/th&gt;
  &lt;tr&gt;
    &lt;td&gt;Access&lt;/td&gt;    &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(n)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Update&lt;/td&gt;    &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(n)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Append&lt;/td&gt;    &lt;td&gt;O(1)/O(n)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Traversal&lt;/td&gt; &lt;td&gt;O(n)&lt;/td&gt;  &lt;td&gt;O(n)&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

Always think about the performance of the data structure

How about an "arraylist"?

---

# Lists: Standard Library

        import java.util.LinkedList;
        import java.util.ArrayList;
        import java.util.List;

        // ...

        List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
        List&lt;Integer&gt; b = new LinkedList&lt;Integer&gt;();

        for (int i = 0; i &lt; 10; i++) {
            a.add(i);
            b.add(i);
        }
        a.set(5, 0);
        b.remove(5);
        System.out.println(a); // [0, 1, 2, 3, 4, 0, 6, 7, 8, 9]
        System.out.println(b); // [0, 1, 2, 3, 4, 6, 7, 8, 9]

---

# Linked list: Question

How do you reverse a linked list?

---

# Linked list: Question

      public static Node reverse(Node head) {
          Node prev = null;
          Node curr = head;
          Node next;

          while (curr != null ) {
              next = curr.next;
              curr.next = prev;
              prev = curr;
              curr = next;
          }
          return prev;
      }

---

# Stacks

![Stack](http://www.cs.cmu.edu/~mrmiller/15-121/Homework/hw8/stack.png)

---

# Stacks

    // Last-in first-out data structure
    public interface MyStack {
        // Add a value to the stack
        public void push(int value);

        // Remove a value from the stack
        public int pop();

        // See the value on the "top" of the stack (next to be removed)
        public int peek();
    }

    MyStack a = ...; // [ ]
    a.push(1); // [ 1 ]
    a.push(2); // [ 2 1 ]
    a.peek(); // returns 2
    a.push(3); // [ 3 2 1 ]
    a.pop(); // [ 2 1 ], returns 3
    a.push(4); // [ 4 2 1 ]
    a.peek(); // returns 4

---

# Stacks

&lt;table&gt;
  &lt;th&gt;
    &lt;td&gt;Array&lt;/td&gt; &lt;td&gt;List&lt;/td&gt;
  &lt;/th&gt;
  &lt;tr&gt;
    &lt;td&gt;Push&lt;/td&gt;      &lt;td&gt;O(1)/O(n)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Pop&lt;/td&gt;       &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Peek&lt;/td&gt;      &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

---

# Stacks: Standard Library

        Stack&lt;Integer&gt; a = new Stack&lt;Integer&gt;();

        a.push(1);
        a.push(2);
        System.out.println(a.pop()); // 2
        a.push(3);
        System.out.println(a); // [1, 3]

---

# Stacks: Question

Write a function to determine if a string consisting of the characters '{', '}',
'[', and ']' is balanced.

For example, "{[]}" is balanced, and "{[}]" is not.

---

# Stacks: Question

    public static boolean isBalanced(String braces) {
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        for (int i = 0; i &lt; braces.length(); i++) {
            switch (braces.charAt(i)) {
                case '{': stack.push('{');
                    break;
                case '[': stack.push('[');
                    break;
                case '}': if (stack.pop() != '{') { return false; }
                    break;
                case ']': if (stack.pop() != '[') { return false; }
                    break;
            }
        }
        return stack.isEmpty();
    }

---

# Queues

![Queue](http://www.mmrelearning.ca/pluginfile.php/8007/mod_page/content/1/Unit_7_Linked_Lists/queue.jpg)

---

# Queues

    // First-in first-out data structure
    public interface MyQueue {
        // Add a value to the back of the queue
        public void enqueue(int value);

        // Remove a value from front of the queue
        public int dequeue();

        // See the value on the "front" of the queue (next to be removed)
        public int peek();
    }

    MyStack a = ...; // [ ]
    a.enqueue(1); // [ 1 ]
    a.enqueue(2); // [ 1 2 ]
    a.peek(); // returns 1
    a.enqueue(3); // [ 1 2 3 ]
    a.dequeue(); // [ 2 3 ], returns 1
    a.enqueue(4); // [ 2 3 4 ]
    a.peek(); // returns 2

---

# Queues

&lt;table&gt;
  &lt;th&gt;
    &lt;td&gt;Array&lt;/td&gt; &lt;td&gt;List&lt;/td&gt;
  &lt;/th&gt;
  &lt;tr&gt;
    &lt;td&gt;Enqueue&lt;/td&gt;   &lt;td&gt;O(1)/O(n)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Dequeue&lt;/td&gt;   &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Peek&lt;/td&gt;      &lt;td&gt;O(1)&lt;/td&gt;  &lt;td&gt;O(1)&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

---

# Queues: Standard Library

      import java.util.Queue;
      import java.util.ArrayDeque;

      Queue&lt;String&gt; stack = new ArrayDeque&lt;String&gt;();

---

# Queues: Question

Given one queue and one stack, how do you reverse the stack?

---

# Queues: Question

        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();

        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack); // [1, 2, 3]
        while (!stack.isEmpty()) {
            queue.add(stack.pop());
        }
        while (!queue.isEmpty()) {
            stack.push(queue.remove());
        }
        System.out.println(stack); // [3, 2, 1]

---

# Hash Maps

An absolutely essential concept.

Supported operations:

* insert()
* delete()
* find()

Why is it so impressive? All of these operations can be done in constant O(1) time.

---

# Hash Maps

Think of a hash map like a really really big array.

    array[0] = 1 // insert(): O(1)
    array[1] = null // delete(): O(1)
    x = array[2] // find(): O(1)

An array that, instead of integer indexes, has indexes that can be anything.

    map["0"] -&gt; 1
    map["Adam Cannon"] -&gt; 1004
    map["BullsAndCows"] -&gt; 9001
    map["thisisareallylongstringthatistoocoolomgomgomgomgomgomgadiadiadilove"] -&gt; 0

Insert, find, and delete are all O(1) now. That's it?

---

# Hash Maps

No. :( An infinite size array for infinite possible indexes is unreasonable.

As it turns out, however, there's a way to simplify anything (String, object, integer) into an integer

This is called the **Hash function**: maps an object (of some type) to an integer.

Example:

    x % 10027

---

# Hash Maps

**Hash function**: maps an object (of some type) to an integer.

Example:

    public int hash(String s) {
        int hashVal = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            hashVal = s.charAt(i) + hashVal * 37;
        }
        return hashVal;
    }

---

# Hash Maps

For insert():

1. Take any thing `X` that maps to `Y`
2. Simplify `X` into an integer `i` using a hash function
3. Set `array[i] = Y`

For find():

1. Take any thing `X` that you want to find `Y` for.
2. Simplify `X` into an integer `i` using the same hash function
3. Set `Y = array[i]`

---

# Hash Maps

This is awesome!

Well, there are some problems with hash maps

* Requires a lot of extra memory and a good hash function to avoid collisions
* What is a "good" hash function?
* Finding max or min is kind of difficult

But in general: excellent for what it can do.

---

# Hash Maps: Standard library

    import java.util.HashSet;
    import java.util.HashMap;

    // ...

    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
    set.add("dog");
    set.add("cat");
    set.add("fish");
    System.out.println(set.contains("dog")); // true
    System.out.println(set.contains("horse")); // false

    HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    map.put("Jenny", "867-5309");
    System.out.println(map.get("Jenny")); // 867-5309

---

# Hash Maps: Question

Implement a word counter (not case sensitive, and ignoring special characters).

Example:

    "Gabba gabba hey, gabba gabba hey!" -&gt; { "gabba": 4, "hey": 2 }

---

# Hash Maps: Question

    import java.util.HashMap;

    public static HashMap&lt;String, Integer&gt; countWords(String document) {
        HashMap&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();
        for (String word : document.split(" ")) {
            String key = word.toLowerCase().replaceAll("[^a-zA-Z]", "");
            if (counts.containsKey(key)) {
                counts.put(key, counts.get(key) + 1);
            } else {
                counts.put(key, 1);
            }
        }
        return counts;
    }

---

# Other Hash-y Things

Hashtables, HashSets, Dictionaries (Python)

Slight variations, but all revolve around the same idea of index simplification via a hash function for constant time insert, delete, and find.

If you are really interested, lookup how to resolve hash map collisions or textbook hash functions

---

# Trees

![Tree](http://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg)

---

# Trees

    public class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }

        public Node(int value) {
            this(value, null, null);
        }
    }

---

# Trees

These are **mad** useful. Can represent hierarchical data: parse trees in NLP, database indexes, etc.

Fast Vocabulary

* Root – The top node in a tree.
* Parent – The converse notion of child.
* Siblings – Nodes with the same parent.
* Descendant – a node reachable by repeated proceeding from parent to child.
* Ancestor – a node reachable by repeated proceeding from child to parent.
* Leaf – a node with no children.
* Edge – connection between one node to another.
* Path – a sequence of nodes and edges connecting a node with a descendant.
* Level – The level of a node is defined by 1 + the number of connections between the node and the root.
* Height – The height of a node is the number of edges on the longest downward path between the root and a leaf.

---

# Trees: Binary Search Tree

**Binary Search Tree**: every value in the left subtree of a node with a value is less than that value; every value in the right subtree of a node with a value is greater than that value.

This gives us O(log(n)) retrieval (in the average but not worst case; more on that later).

---

# Trees: Binary Search Tree

![BST](http://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)

Before we move further...

---

# Recursion

      public int fib(int n) {
          if (n &lt; 2) {
              return 1;
          } else {
              return fib(n - 1) + fib(n - 2);
          }
      }

---

# Trees: Binary Search Tree

    public boolean find(Node root, int value) {
        if (root == null) {
            return false;
        }
        if (value &lt; root.value) {
            return find(root.left, value);
        } else if (value &gt; root.value) {
            return find(root.right, value);
        } else {
            return true;
        }
    }

---

# Trees: Binary Search Tree

Worst Case: Unbalanced Tree

![BST worst](http://epaperpress.com/sortsearch/images/fig33.gif)

---

# Trees: Traversal

We can traverse the tree in one of a few ways.

## Pre-Order (XLR)

![preorder](http://upload.wikimedia.org/wikipedia/commons/d/d4/Sorted_binary_tree_preorder.svg)

FBADCEGIH

---

# Trees: Traversal

We can traverse the tree in one of a few ways.

## In-Order (LXR)

![inorder](http://upload.wikimedia.org/wikipedia/commons/7/77/Sorted_binary_tree_inorder.svg)

ABCDEFGHI

---

# Trees: Traversal

We can traverse the tree in one of a few ways.

## Post-Order (LRX)

![postorder](http://upload.wikimedia.org/wikipedia/commons/9/9d/Sorted_binary_tree_postorder.svg)

ACEDBHIGF

---

# Trees: Question

How do we do a level-order traversal of a tree?

![levelorder](http://upload.wikimedia.org/wikipedia/commons/d/d1/Sorted_binary_tree_breadth-first_traversal.svg)

---

# Trees: Question

    public void levelOrder(Node root) {
        Queue&lt;Node&gt; queue = new Queue&lt;Node&gt;();
        queue.add(root);
        while (!queue.isEmpty()) {
            Node curr = queue.remove();
            System.out.println(curr.value);
            if (curr.left != null) {
                queue.add(curr.left);
            }
            if (curr.right != null) {
                queue.add(curr.right);
            }
        }
    }


---

# Trees: Heap

A Priority Queue is an ADT is a list where each element has a "priority" associated with it.

Operations:

* `insert_with_priority()`
* `pull_highest_priority_element()`

---

# Trees: Heap

The maximally efficient way to implement this ADT is with a heap (`O(log n)` performance for both operations)

Heap Property: Parents are always more important than their children

![heap](http://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)

---

# Trees: Heap

To add an element: insert and reorder the tree (`O(log n)`)

To pull the highest priority element: pop the root out and reorder the tree (`O(log n)`)

---

# More About Trees

AVL Trees (Trees that always stay balanced using rotation)

Red-Black Trees (Trees that always stay balanced using colors (fun!))

B-Trees (Trees designed for lots of data)

---
# Graphs

ADT consisting of Nodes and Edges

![heap](http://upload.wikimedia.org/wikipedia/commons/a/a2/Directed.svg)

---

# Graphs

Basic operations:

* `adjacent(G, x, y)`: tests whether there is an edge from node x to node y.
* `neighbors(G, x)`: lists all nodes y such that there is an edge from x to y.
* `add(G, x, y)`: adds to G the edge from x to y, if it is not there.
* `delete(G, x, y)`: removes the edge from x to y, if it is there.
* `get_node_value(G, x)`: returns the value associated with the node x.
* `set_node_value(G, x, a)`: sets the value associated with the node x to a.
* `get_edge_value(G, x, y)`: returns the value associated to the edge (x,y).
* `set_edge_value(G, x, y, v)`: sets the value associated to the edge (x,y) to v.

---

# Graphs: Implementation

One way is to use an "adjacency list": We have a list of nodes and every node stores a list of adjacent nodes.

    public class Node {
      public int value;
      public ArrayList&lt;Edges&gt; edges;
    }

    public class Edge {
      public Node destination;
      public int weight;
    }

    public class Graph {
      public ArrayList&lt;Node&gt; nodes;
    }

---

# Graphs: Performance

Say we have V nodes and E edges.

What is the performance for these operations?

* Add vertex
* Add edge
* Remove vertex
* Remove edge

Depends on implementation, but this is something you look up.

---
# Graphs: Searching

Problem: Given a node, can we reach this other node?

Search!

---
# Graphs: Depth First Search (DFS)

    bool search(Node root, Node dest) {
      if (root.value == dest.value)
        return true;
      root.visited = true;
      for (Node n : root.adjacent) {
        if (!n.visited) {
          if (search(n, dest))
            return true;
        }
      }
      return false;
    }

---
# Graphs: Breadth First Search (BFS)

    bool search(Node root, Node dest) {
      Queue q = new Queue();
      if (root.value == dest.value)
        return true;
      root.visited = true;
      q.enqueue(root);
      while (!q.isEmpty()) {
        Node r = q.dequeue();
        for (Node n in r.adjacent) {
          if (!n.visited) {
            if (search(n, dest))
              return true;
            queue.enqueue(n);
          }
        }
      }
      return false;
    }

---
# Graphs: More

Interesting Graph Problems (wiki):

* Djikstra's
* Floyd-Warshall
* Ford-Fulkerson
* Kruskal's

---

# Sorting

The problem: given an array containing many values, permute the array so that
those values are in order.

You'll definitely be expected to have a high-level understanding of these and
know the runtimes. Maybe you'll have to implement one.

---

# Sorting

## A common tool: swapping

    private static void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }

---

# Sorting: Selection Sort

![Selection Numbers](http://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)

Basically, find the minimum element n times.

---

# Sorting: Selection Sort

    public static void selectionSort(int array[]) {
        for (int i = 0; i &lt; array.length; i++) {
            int minIndex = i;
            for (int j = i; j &lt; array.length; j++) {
                if (array[j] &lt; array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array, i, minIndex);
        }
    }

General Information

* O(n^2) performance
* O(1) space


---

# Sorting: Bubble Sort

![Bubble Numbers](http://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)

The maximum elements bubble to the top 

---

# Sorting: Bubble Sort

     public static void bubbleSort(int array[]) {
         for (int i = 0; i &lt; array.length; i++) {
            for (int j = 0; j &lt; array.length - 1; j++) {
                if (array[j] &gt; array[j + 1]) {
                    swap(array, j, j + 1);
                }
            }
         }
     }

General information

* O(n^2) performance
* O(1) space

---

# Sorting: Merge sort

![Merge Numbers](http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)

1. Split the array in half and sort each subarray.
2. Weave the arrays back together in one fluid pass.

---

# Sorting: Merge sort

Here's where I'm going to stop implementing things and just explain them.
Wikipedia is great.

Merge sort is recursive.

    function mergeSort(A):
        split A into A_beginning and A_end at the middle
        mergeSort(A_beginning)
        mergeSort(A_end)
        return merge(A_beginning, A_end)

General Information

* O(n log n) performance
* O(n) space

---

# Sorting: Quicksort

![Quicksort Numbers](http://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif)

"Divide and Conquer"

---

# Sorting: Quicksort

    function quickSort(A):
        pick a "pivot" element in A
        move all elements less than the pivot to the beginning of A
        move all elements greater than the pivot to the end of A
        put the pivot in the middle
        quicksort the beginning of A recursively
        quicksort the end of A recursively

General Information

* O(n log n) performance
* Absolute worst case O(n^2) performance

---

# Sorting: Counting sort

Comparison-based sorts can't be faster than n * log(n). BUT non-comparison based
ones can. There are catches, though.

    public void countingSort(int[] array, int max) {
        int[] counts = new int[max];
        for (int i = 0; i &lt; array.length; i++) {
            counts[array[i] - 1]++;
        }
        int i = 0;
        for (int j = 0; j &lt; max; j++) {
            while (counts[j] &gt; 0) {
                array[i++] = j + 1;
            }
        }
    }

This is a prime example of how NOT to implement a hash map.

---

# Sorting: In General

Anything slower than O(n^2) is not okay.

O(n^2) sorting algorithms are generally simpler, easier to code, and require less auxillary space

O(n log n) is the best comparison based sorting algorithm performance you can get (proven mathematically). These, however, tend to be more complicated and require more memory.

Faster than O(n log n) sorting sorting usually makes at least one huge assumption about our data set (e.g. counting sort)

---

# Sorting: An Interview Question

You are given an unsorted array of size n. However, you are also told that where each element is in the unsorted array right now is at most k-1 positions away from its final correctly sorted position. You are told that 1 &lt; k &lt; n.

What is the best sorting strategy and what is our performance?

---

# Sorting: An Interview Question

Solution (in Python):

    import heapq

    def better_sort(array, k):
        final_array = []
        heap = []
        for x in xrange(k):
            heapq.heappush(heap, array[x])
        index = k
        while heap:
            final_array.append(heapq.heappop(heap))
            if index &lt; len(array):
                heapq.heappush(heap, array[index])
                index += 1
        return final_array

Performance: O(n log k)

---

# Other things to know:

* How to code in your interview language

* How to use Unix (scripting, regexes)

* How a computer works (bits and bytes)

* Object-oriented programming

---

# Sample Interview Questions

https://github.com/adicu/interview_help

---

# Other resources

* Cracking the Coding Interview

* Google / Wikipedia

* ICPC

* CLRS

* https://adicu.com/resources

![ADI](http://adicu.com/img/logo.png)

    </textarea>
    <div id="slideshow" style="width: 908px; height: 681px; transform: scale(1.31718); left: 352.5px; top: 0px;"><div class="slide" style="display: none;"><div class="content center middle"><h1>Data Structures for Interviews</h1>
<p>2014-10-22

</p>
<p>Justin Zhao, ADI

</p>
<p>Adapted from Zack Newman

</p>
<p>adicu.com
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Expectations for this talk</h1>
<p>I assume familiarity with Java (if you know some other language, you can probably
figure it out). I didn't check all of my code.

</p>
<p>The is <strong>not</strong> a replacement for 3134. It should be a good preview that gets you
ready for some basic interviews.

</p>
<p>PLEASE stop me if I say something that doesn't make sense.

</p>
<blockquote>
<p>He who asks is a fool for five minutes, but he who does not ask remains a fool forever.
<span class="right"><em>Chinese Proverb</em></span>
</p>
</blockquote>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Gameplan</h1>
<ul>
<li><p>Review of Big O </p>
</li>
<li><p>Data Structures</p>
</li>
<li><p>Sorting Algorithms</p>
</li>
<li><p>Sample Interview Questions</p>
</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>What Will Be Covered</h1>
<ul>
<li><p>Functionality, operations, applicability of data structures</p>
</li>
<li><p>Overview of important data structure algorithms and performance</p>
</li>
<li><p>Sample interview questions and how to tackle them with data structures</p>
</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>What Will Not Be Covered</h1>
<ul>
<li><p>The answers to every interview question</p>
</li>
<li><p>Best interview strategies (interview practice)</p>
</li>
<li><p>Implementation details (3134)</p>
</li>
</ul>
<blockquote>
<p>It's probably good for you to understand details of implementation, but not necessary for most interviews
</p>
</blockquote>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Review of Big O</h1>
<ul>
<li><p>"Big O" is the "asymptotic runtime"</p>
</li>
<li><p>Expressed as function of the size of the inputs</p>
</li>
<li><p>Consider best, worst, and average cases</p>
</li>
</ul>
<p><img src="./Data Structures for Interviews_files/WcBRI.png" alt="Big O">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Review of Big O</h1>
<pre><code class="java"><span class="javadoc">/**
 * Return the index of the minimum element in an integer array.
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> findMin(<span class="keyword">int</span>[] array) {
    <span class="keyword">int</span> minIndex = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {
        <span class="keyword">if</span> (array[i] &lt; array[minIndex]) {
            minIndex = i;
        }
    }
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Review of Big O</h1>
<pre><code class="java"><span class="javadoc">/**
 * Return the index of the minimum element in an integer array.
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> findMin(<span class="keyword">int</span>[] array) {
    <span class="keyword">int</span> minIndex = <span class="number">0</span>; <span class="comment">// O(1)</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) { <span class="comment">// n times</span>
        <span class="keyword">if</span> (array[i] &lt; array[minIndex]) { <span class="comment">// O(1)</span>
            minIndex = i; <span class="comment">// O(1)</span>
        }
    }
} <span class="comment">// O(1) + n (O(1) + O(1)) = O(1) + n O(1) = O(1) + O(n) = O(n)</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Review of Big O</h1>
<pre><code class="java"><span class="javadoc">/**
 * Return the index of array (which must be sorted) at which value can be
 * found, or -1 if it is absent.
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> find(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value) {
    <span class="keyword">return</span> findHelper(array, <span class="number">0</span>, array.length - <span class="number">1</span>, value);
} <span class="comment">// O(lg n)</span>

<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> findHelper(<span class="keyword">int</span>[] array, <span class="keyword">int</span> minIndex, <span class="keyword">int</span> maxIndex,
        <span class="keyword">int</span> value) {
    <span class="keyword">if</span> (maxIndex &lt; minIndex) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }

    <span class="keyword">int</span> index = (maxIndex + minIndex) / <span class="number">2</span>;
    <span class="keyword">if</span> (value &lt; array[index]) {
        <span class="keyword">return</span> findHelper(array, minIndex, index, value);
    } <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; array[index]) {
        <span class="keyword">return</span> findHelper(array, index + <span class="number">1</span>, maxIndex, value);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> index;
    }
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Review of Big O</h1>
<p>Which performance is better?

</p>
<p><code class="no-highlight">O(10000 n)</code> vs. <code class="no-highlight">O(n)</code>

</p>
<p><code class="no-highlight">O(log n)</code> vs. <code class="no-highlight">O(log(log n))</code>

</p>
<p><code class="no-highlight">O(n log n)</code> vs. <code class="no-highlight">O(n log k)</code>

</p>
<p><code class="no-highlight">O(0.000001 n^2)</code> vs. <code class="no-highlight">O(9999999 n^1.999999)</code>

</p>
<p><code class="no-highlight">O(2^n)</code> vs. <code class="no-highlight">O(3^n)</code>

</p>
<p><code class="no-highlight">O(n!)</code> vs. <code class="no-highlight">O(n^n)</code>
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Abstract Data Type (ADT)</h1>
<ul>
<li><p>What is a "data structure" anyway? We define ADTs first</p>
</li>
<li><p>An interface for interacting with data</p>
</li>
<li><p>lists, stacks, sets, queues, maps, trees, priority queue etc.</p>
</li>
<li><p>Defines operations and results, but not how they're implemented</p>
</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Data Structures</h1>
<ul>
<li><p>Data Structure is an implementation of ADT</p>
</li>
<li><p>For example, an "ArrayList" or "HashMap"</p>
</li>
<li><p>Many ADTs can be implemented as the same Data Structure.</p>
</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Data Structure Primitives</h1>
<h2>Arrays</h2>
<pre><code class="cpp">  <span class="keyword">int</span>[] <span class="built_in">array</span> = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>};

  <span class="comment">/*
   * Index: 0 1 2 3 4 5
   * Value: 1 3 5 2 6 9
   */</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Data Structure Primitives</h1>
<h2>Linked lists</h2>
<p><img src="./Data Structures for Interviews_files/C_language_linked_list.png" alt="Linked List">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Data Structure Primitives</h1>
<h2>Linked lists</h2>
<pre><code class="cs">  <span class="comment">// Attributes</span>
  <span class="keyword">public</span> <span class="keyword">class</span> Node {
      <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;
      <span class="keyword">public</span> Node next;

      <span class="keyword">public</span> Node(<span class="keyword">int</span> <span class="keyword">value</span>, Node next) {
          <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;
          <span class="keyword">this</span>.next = next;
      }
  }

  <span class="comment">// Methods</span>
  <span class="keyword">public</span> <span class="keyword">interface</span> MyList {
      <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">get</span>(<span class="keyword">int</span> index);

      <span class="keyword">public</span> <span class="keyword">void</span> update(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="keyword">value</span>);

      <span class="keyword">public</span> <span class="keyword">void</span> append(<span class="keyword">int</span> <span class="keyword">value</span>);

      <span class="keyword">public</span> String toString();
  }</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>List Performance</h1>
<table>
  <tbody><tr><th>
    </th><td>Array</td> <td>List</td>
  
  </tr><tr>
    <td>Access</td>    <td>O(1)</td>  <td>O(n)</td>
  </tr>
  <tr>
    <td>Update</td>    <td>O(1)</td>  <td>O(n)</td>
  </tr>
  <tr>
    <td>Append</td>    <td>O(1)/O(n)</td>  <td>O(1)</td>
  </tr>
  <tr>
    <td>Traversal</td> <td>O(n)</td>  <td>O(n)</td>
  </tr>
</tbody></table>


<p>Always think about the performance of the data structure

</p>
<p>How about an "arraylist"?
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Lists: Standard Library</h1>
<pre><code class="objectivec">    import java<span class="variable">.util</span><span class="variable">.LinkedList</span>;
    import java<span class="variable">.util</span><span class="variable">.ArrayList</span>;
    import java<span class="variable">.util</span><span class="variable">.List</span>;

    <span class="comment">// ...</span>

    List&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
    List&lt;Integer&gt; b = new LinkedList&lt;Integer&gt;();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        a<span class="variable">.add</span>(i);
        b<span class="variable">.add</span>(i);
    }
    a<span class="variable">.set</span>(<span class="number">5</span>, <span class="number">0</span>);
    b<span class="variable">.remove</span>(<span class="number">5</span>);
    System<span class="variable">.out</span><span class="variable">.println</span>(a); <span class="comment">// [0, 1, 2, 3, 4, 0, 6, 7, 8, 9]</span>
    System<span class="variable">.out</span><span class="variable">.println</span>(b); <span class="comment">// [0, 1, 2, 3, 4, 6, 7, 8, 9]</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Linked list: Question</h1>
<p>How do you reverse a linked list?
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Linked list: Question</h1>
<pre><code class="perl">  public static Node <span class="keyword">reverse</span>(Node head) {
      Node prev = null;
      Node curr = head;
      Node <span class="keyword">next</span>;

      <span class="keyword">while</span> (curr != null ) {
          <span class="keyword">next</span> = curr.<span class="keyword">next</span>;
          curr.<span class="keyword">next</span> = prev;
          prev = curr;
          curr = <span class="keyword">next</span>;
      }
      <span class="keyword">return</span> prev;
  }</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks</h1>
<p><img src="./Data Structures for Interviews_files/stack.png" alt="Stack">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks</h1>
<pre><code class="objectivec"><span class="comment">// Last-in first-out data structure</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="id">MyStack</span> {</span>
    <span class="comment">// Add a value to the stack</span>
    <span class="keyword">public</span> <span class="keyword">void</span> push(<span class="keyword">int</span> value);

    <span class="comment">// Remove a value from the stack</span>
    <span class="keyword">public</span> <span class="keyword">int</span> pop();

    <span class="comment">// See the value on the "top" of the stack (next to be removed)</span>
    <span class="keyword">public</span> <span class="keyword">int</span> peek();
}

MyStack a = ...; <span class="comment">// [ ]</span>
a<span class="variable">.push</span>(<span class="number">1</span>); <span class="comment">// [ 1 ]</span>
a<span class="variable">.push</span>(<span class="number">2</span>); <span class="comment">// [ 2 1 ]</span>
a<span class="variable">.peek</span>(); <span class="comment">// returns 2</span>
a<span class="variable">.push</span>(<span class="number">3</span>); <span class="comment">// [ 3 2 1 ]</span>
a<span class="variable">.pop</span>(); <span class="comment">// [ 2 1 ], returns 3</span>
a<span class="variable">.push</span>(<span class="number">4</span>); <span class="comment">// [ 4 2 1 ]</span>
a<span class="variable">.peek</span>(); <span class="comment">// returns 4</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks</h1>
<table>
  <tbody><tr><th>
    </th><td>Array</td> <td>List</td>
  
  </tr><tr>
    <td>Push</td>      <td>O(1)/O(n)</td>  <td>O(1)</td>
  </tr>
  <tr>
    <td>Pop</td>       <td>O(1)</td>  <td>O(1)</td>
  </tr>
  <tr>
    <td>Peek</td>      <td>O(1)</td>  <td>O(1)</td>
  </tr>
</tbody></table>

</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks: Standard Library</h1>
<pre><code class="objectivec">    Stack&lt;Integer&gt; a = new Stack&lt;Integer&gt;();

    a<span class="variable">.push</span>(<span class="number">1</span>);
    a<span class="variable">.push</span>(<span class="number">2</span>);
    System<span class="variable">.out</span><span class="variable">.println</span>(a<span class="variable">.pop</span>()); <span class="comment">// 2</span>
    a<span class="variable">.push</span>(<span class="number">3</span>);
    System<span class="variable">.out</span><span class="variable">.println</span>(a); <span class="comment">// [1, 3]</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks: Question</h1>
<p>Write a function to determine if a string consisting of the characters '{', '}',
'[', and ']' is balanced.

</p>
<p>For example, "{[]}" is balanced, and "{[}]" is not.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Stacks: Question</h1>
<pre><code class="cpp"><span class="keyword">public</span> <span class="keyword">static</span> boolean isBalanced(String braces) {
    Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;Character&gt;();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; braces.length(); i++) {
        <span class="keyword">switch</span> (braces.charAt(i)) {
            <span class="keyword">case</span> <span class="string">'{'</span>: <span class="built_in">stack</span>.push(<span class="string">'{'</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'['</span>: <span class="built_in">stack</span>.push(<span class="string">'['</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'}'</span>: <span class="keyword">if</span> (<span class="built_in">stack</span>.pop() != <span class="string">'{'</span>) { <span class="keyword">return</span> <span class="keyword">false</span>; }
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span> (<span class="built_in">stack</span>.pop() != <span class="string">'['</span>) { <span class="keyword">return</span> <span class="keyword">false</span>; }
                <span class="keyword">break</span>;
        }
    }
    <span class="keyword">return</span> <span class="built_in">stack</span>.isEmpty();
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues</h1>
<p><img src="http://www.mmrelearning.ca/pluginfile.php/8007/mod_page/content/1/Unit_7_Linked_Lists/queue.jpg" alt="Queue">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues</h1>
<pre><code class="objectivec"><span class="comment">// First-in first-out data structure</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="id">MyQueue</span> {</span>
    <span class="comment">// Add a value to the back of the queue</span>
    <span class="keyword">public</span> <span class="keyword">void</span> enqueue(<span class="keyword">int</span> value);

    <span class="comment">// Remove a value from front of the queue</span>
    <span class="keyword">public</span> <span class="keyword">int</span> dequeue();

    <span class="comment">// See the value on the "front" of the queue (next to be removed)</span>
    <span class="keyword">public</span> <span class="keyword">int</span> peek();
}

MyStack a = ...; <span class="comment">// [ ]</span>
a<span class="variable">.enqueue</span>(<span class="number">1</span>); <span class="comment">// [ 1 ]</span>
a<span class="variable">.enqueue</span>(<span class="number">2</span>); <span class="comment">// [ 1 2 ]</span>
a<span class="variable">.peek</span>(); <span class="comment">// returns 1</span>
a<span class="variable">.enqueue</span>(<span class="number">3</span>); <span class="comment">// [ 1 2 3 ]</span>
a<span class="variable">.dequeue</span>(); <span class="comment">// [ 2 3 ], returns 1</span>
a<span class="variable">.enqueue</span>(<span class="number">4</span>); <span class="comment">// [ 2 3 4 ]</span>
a<span class="variable">.peek</span>(); <span class="comment">// returns 2</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues</h1>
<table>
  <tbody><tr><th>
    </th><td>Array</td> <td>List</td>
  
  </tr><tr>
    <td>Enqueue</td>   <td>O(1)/O(n)</td>  <td>O(1)</td>
  </tr>
  <tr>
    <td>Dequeue</td>   <td>O(1)</td>  <td>O(1)</td>
  </tr>
  <tr>
    <td>Peek</td>      <td>O(1)</td>  <td>O(1)</td>
  </tr>
</tbody></table>

</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues: Standard Library</h1>
<pre><code class="xml">  import java.util.Queue;
  import java.util.ArrayDeque;

  Queue<span class="tag">&lt;<span class="title">String</span>&gt;</span> stack = new ArrayDeque<span class="tag">&lt;<span class="title">String</span>&gt;</span>();</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues: Question</h1>
<p>Given one queue and one stack, how do you reverse the stack?
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Queues: Question</h1>
<pre><code class="cpp">    Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;Integer&gt;();
    Queue&lt;Integer&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();

    <span class="built_in">stack</span>.push(<span class="number">1</span>);
    <span class="built_in">stack</span>.push(<span class="number">2</span>);
    <span class="built_in">stack</span>.push(<span class="number">3</span>);
    System.out.println(<span class="built_in">stack</span>); <span class="comment">// [1, 2, 3]</span>
    <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) {
        <span class="built_in">queue</span>.add(<span class="built_in">stack</span>.pop());
    }
    <span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) {
        <span class="built_in">stack</span>.push(<span class="built_in">queue</span>.remove());
    }
    System.out.println(<span class="built_in">stack</span>); <span class="comment">// [3, 2, 1]</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p>An absolutely essential concept.

</p>
<p>Supported operations:

</p>
<ul>
<li>insert()</li>
<li>delete()</li>
<li>find()</li>
</ul>
<p>Why is it so impressive? All of these operations can be done in constant O(1) time.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p>Think of a hash map like a really really big array.

</p>
<pre><code class="php"><span class="keyword">array</span>[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// insert(): O(1)</span>
<span class="keyword">array</span>[<span class="number">1</span>] = <span class="keyword">null</span> <span class="comment">// delete(): O(1)</span>
x = <span class="keyword">array</span>[<span class="number">2</span>] <span class="comment">// find(): O(1)</span></code></pre>
<p>An array that, instead of integer indexes, has indexes that can be anything.

</p>
<pre><code class="perl"><span class="keyword">map</span>[<span class="string">"0"</span>] -&gt; <span class="number">1</span>
<span class="keyword">map</span>[<span class="string">"Adam Cannon"</span>] -&gt; <span class="number">1004</span>
<span class="keyword">map</span>[<span class="string">"BullsAndCows"</span>] -&gt; <span class="number">9001</span>
<span class="keyword">map</span>[<span class="string">"thisisareallylongstringthatistoocoolomgomgomgomgomgomgadiadiadilove"</span>] -&gt; <span class="number">0</span></code></pre>
<p>Insert, find, and delete are all O(1) now. That's it?
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p>No. :( An infinite size array for infinite possible indexes is unreasonable.

</p>
<p>As it turns out, however, there's a way to simplify anything (String, object, integer) into an integer

</p>
<p>This is called the <strong>Hash function</strong>: maps an object (of some type) to an integer.

</p>
<p>Example:

</p>
<pre><code class="undefined">x % 10027</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p><strong>Hash function</strong>: maps an object (of some type) to an integer.

</p>
<p>Example:

</p>
<pre><code class="objectivec"><span class="keyword">public</span> <span class="keyword">int</span> hash(String s) {
    <span class="keyword">int</span> hashVal = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s<span class="variable">.length</span>(); i++) {
        hashVal = s<span class="variable">.charAt</span>(i) + hashVal * <span class="number">37</span>;
    }
    <span class="keyword">return</span> hashVal;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p>For insert():

</p>
<ol>
<li>Take any thing <code class="no-highlight">X</code> that maps to <code class="no-highlight">Y</code></li>
<li>Simplify <code class="no-highlight">X</code> into an integer <code class="no-highlight">i</code> using a hash function</li>
<li>Set <code class="no-highlight">array[i] = Y</code></li>
</ol>
<p>For find():

</p>
<ol>
<li>Take any thing <code class="no-highlight">X</code> that you want to find <code class="no-highlight">Y</code> for.</li>
<li>Simplify <code class="no-highlight">X</code> into an integer <code class="no-highlight">i</code> using the same hash function</li>
<li>Set <code class="no-highlight">Y = array[i]</code></li>
</ol>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps</h1>
<p>This is awesome!

</p>
<p>Well, there are some problems with hash maps

</p>
<ul>
<li>Requires a lot of extra memory and a good hash function to avoid collisions</li>
<li>What is a "good" hash function?</li>
<li>Finding max or min is kind of difficult</li>
</ul>
<p>But in general: excellent for what it can do.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps: Standard library</h1>
<pre><code class="objectivec">import java<span class="variable">.util</span><span class="variable">.HashSet</span>;
import java<span class="variable">.util</span><span class="variable">.HashMap</span>;

<span class="comment">// ...</span>

HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
set<span class="variable">.add</span>(<span class="string">"dog"</span>);
set<span class="variable">.add</span>(<span class="string">"cat"</span>);
set<span class="variable">.add</span>(<span class="string">"fish"</span>);
System<span class="variable">.out</span><span class="variable">.println</span>(set<span class="variable">.contains</span>(<span class="string">"dog"</span>)); <span class="comment">// true</span>
System<span class="variable">.out</span><span class="variable">.println</span>(set<span class="variable">.contains</span>(<span class="string">"horse"</span>)); <span class="comment">// false</span>

HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
map<span class="variable">.put</span>(<span class="string">"Jenny"</span>, <span class="string">"867-5309"</span>);
System<span class="variable">.out</span><span class="variable">.println</span>(map<span class="variable">.get</span>(<span class="string">"Jenny"</span>)); <span class="comment">// 867-5309</span></code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps: Question</h1>
<p>Implement a word counter (not case sensitive, and ignoring special characters).

</p>
<p>Example:

</p>
<pre><code class="perl"><span class="string">"Gabba gabba hey, gabba gabba hey!"</span> -&gt; { <span class="string">"gabba"</span>: <span class="number">4</span>, <span class="string">"hey"</span>: <span class="number">2</span> }</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Hash Maps: Question</h1>
<pre><code class="objectivec">import java<span class="variable">.util</span><span class="variable">.HashMap</span>;

<span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; countWords(String document) {
    HashMap&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();
    <span class="keyword">for</span> (String word : document<span class="variable">.split</span>(<span class="string">" "</span>)) {
        String key = word<span class="variable">.toLowerCase</span>()<span class="variable">.replaceAll</span>(<span class="string">"[^a-zA-Z]"</span>, <span class="string">""</span>);
        <span class="keyword">if</span> (counts<span class="variable">.containsKey</span>(key)) {
            counts<span class="variable">.put</span>(key, counts<span class="variable">.get</span>(key) + <span class="number">1</span>);
        } <span class="keyword">else</span> {
            counts<span class="variable">.put</span>(key, <span class="number">1</span>);
        }
    }
    <span class="keyword">return</span> counts;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Other Hash-y Things</h1>
<p>Hashtables, HashSets, Dictionaries (Python)

</p>
<p>Slight variations, but all revolve around the same idea of index simplification via a hash function for constant time insert, delete, and find.

</p>
<p>If you are really interested, lookup how to resolve hash map collisions or textbook hash functions
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees</h1>
<p><img src="./Data Structures for Interviews_files/Binary_tree.svg" alt="Tree">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees</h1>
<pre><code class="cs"><span class="keyword">public</span> <span class="keyword">class</span> Node {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">public</span> Node left;
    <span class="keyword">public</span> Node right;

    <span class="keyword">public</span> Node(<span class="keyword">int</span> <span class="keyword">value</span>, Node left, Node right) {
        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;
        <span class="keyword">this</span>.left = left;
        <span class="keyword">this</span>.right = right;
    }

    <span class="keyword">public</span> Node(<span class="keyword">int</span> <span class="keyword">value</span>) {
        <span class="keyword">this</span>(<span class="keyword">value</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
    }
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees</h1>
<p>These are <strong>mad</strong> useful. Can represent hierarchical data: parse trees in NLP, database indexes, etc.

</p>
<p>Fast Vocabulary

</p>
<ul>
<li>Root – The top node in a tree.</li>
<li>Parent – The converse notion of child.</li>
<li>Siblings – Nodes with the same parent.</li>
<li>Descendant – a node reachable by repeated proceeding from parent to child.</li>
<li>Ancestor – a node reachable by repeated proceeding from child to parent.</li>
<li>Leaf – a node with no children.</li>
<li>Edge – connection between one node to another.</li>
<li>Path – a sequence of nodes and edges connecting a node with a descendant.</li>
<li>Level – The level of a node is defined by 1 + the number of connections between the node and the root.</li>
<li>Height – The height of a node is the number of edges on the longest downward path between the root and a leaf.</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Binary Search Tree</h1>
<p><strong>Binary Search Tree</strong>: every value in the left subtree of a node with a value is less than that value; every value in the right subtree of a node with a value is greater than that value.

</p>
<p>This gives us O(log(n)) retrieval (in the average but not worst case; more on that later).
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Binary Search Tree</h1>
<p><img src="./Data Structures for Interviews_files/Binary_search_tree.svg" alt="BST">

</p>
<p>Before we move further...
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Recursion</h1>
<pre><code class="java">  <span class="keyword">public</span> <span class="keyword">int</span> fib(<span class="keyword">int</span> n) {
      <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {
          <span class="keyword">return</span> <span class="number">1</span>;
      } <span class="keyword">else</span> {
          <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);
      }
  }</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Binary Search Tree</h1>
<pre><code class="cs"><span class="keyword">public</span> boolean find(Node root, <span class="keyword">int</span> <span class="keyword">value</span>) {
    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">value</span> &lt; root.<span class="keyword">value</span>) {
        <span class="keyword">return</span> find(root.left, <span class="keyword">value</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &gt; root.<span class="keyword">value</span>) {
        <span class="keyword">return</span> find(root.right, <span class="keyword">value</span>);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Binary Search Tree</h1>
<p>Worst Case: Unbalanced Tree

</p>
<p><img src="./Data Structures for Interviews_files/fig33.gif" alt="BST worst">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Traversal</h1>
<p>We can traverse the tree in one of a few ways.

</p>
<h2>Pre-Order (XLR)</h2>
<p><img src="./Data Structures for Interviews_files/Sorted_binary_tree_preorder.svg" alt="preorder">

</p>
<p>FBADCEGIH
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Traversal</h1>
<p>We can traverse the tree in one of a few ways.

</p>
<h2>In-Order (LXR)</h2>
<p><img src="./Data Structures for Interviews_files/Sorted_binary_tree_inorder.svg" alt="inorder">

</p>
<p>ABCDEFGHI
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Traversal</h1>
<p>We can traverse the tree in one of a few ways.

</p>
<h2>Post-Order (LRX)</h2>
<p><img src="./Data Structures for Interviews_files/Sorted_binary_tree_postorder.svg" alt="postorder">

</p>
<p>ACEDBHIGF
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Question</h1>
<p>How do we do a level-order traversal of a tree?

</p>
<p><img src="./Data Structures for Interviews_files/Sorted_binary_tree_breadth-first_traversal.svg" alt="levelorder">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Question</h1>
<pre><code class="objectivec"><span class="keyword">public</span> <span class="keyword">void</span> levelOrder(Node root) {
    Queue&lt;Node&gt; queue = new Queue&lt;Node&gt;();
    queue<span class="variable">.add</span>(root);
    <span class="keyword">while</span> (!queue<span class="variable">.isEmpty</span>()) {
        Node curr = queue<span class="variable">.remove</span>();
        System<span class="variable">.out</span><span class="variable">.println</span>(curr<span class="variable">.value</span>);
        <span class="keyword">if</span> (curr<span class="variable">.left</span> != null) {
            queue<span class="variable">.add</span>(curr<span class="variable">.left</span>);
        }
        <span class="keyword">if</span> (curr<span class="variable">.right</span> != null) {
            queue<span class="variable">.add</span>(curr<span class="variable">.right</span>);
        }
    }
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Heap</h1>
<p>A Priority Queue is an ADT is a list where each element has a "priority" associated with it.

</p>
<p>Operations:

</p>
<ul>
<li><code class="no-highlight">insert_with_priority()</code></li>
<li><code class="no-highlight">pull_highest_priority_element()</code></li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Heap</h1>
<p>The maximally efficient way to implement this ADT is with a heap (<code class="no-highlight">O(log n)</code> performance for both operations)

</p>
<p>Heap Property: Parents are always more important than their children

</p>
<p><img src="./Data Structures for Interviews_files/Max-Heap.svg" alt="heap">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Trees: Heap</h1>
<p>To add an element: insert and reorder the tree (<code class="no-highlight">O(log n)</code>)

</p>
<p>To pull the highest priority element: pop the root out and reorder the tree (<code class="no-highlight">O(log n)</code>)
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>More About Trees</h1>
<p>AVL Trees (Trees that always stay balanced using rotation)

</p>
<p>Red-Black Trees (Trees that always stay balanced using colors (fun!))

</p>
<p>B-Trees (Trees designed for lots of data)
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs</h1>
<p>ADT consisting of Nodes and Edges

</p>
<p><img src="./Data Structures for Interviews_files/Directed.svg" alt="heap">
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs</h1>
<p>Basic operations:

</p>
<ul>
<li><code class="no-highlight">adjacent(G, x, y)</code>: tests whether there is an edge from node x to node y.</li>
<li><code class="no-highlight">neighbors(G, x)</code>: lists all nodes y such that there is an edge from x to y.</li>
<li><code class="no-highlight">add(G, x, y)</code>: adds to G the edge from x to y, if it is not there.</li>
<li><code class="no-highlight">delete(G, x, y)</code>: removes the edge from x to y, if it is there.</li>
<li><code class="no-highlight">get_node_value(G, x)</code>: returns the value associated with the node x.</li>
<li><code class="no-highlight">set_node_value(G, x, a)</code>: sets the value associated with the node x to a.</li>
<li><code class="no-highlight">get_edge_value(G, x, y)</code>: returns the value associated to the edge (x,y).</li>
<li><code class="no-highlight">set_edge_value(G, x, y, v)</code>: sets the value associated to the edge (x,y) to v.</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: Implementation</h1>
<p>One way is to use an "adjacency list": We have a list of nodes and every node stores a list of adjacent nodes.

</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> {</span>
  <span class="keyword">public</span> <span class="keyword">int</span> value;
  <span class="keyword">public</span> ArrayList&lt;Edges&gt; edges;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> {</span>
  <span class="keyword">public</span> Node destination;
  <span class="keyword">public</span> <span class="keyword">int</span> weight;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> {</span>
  <span class="keyword">public</span> ArrayList&lt;Node&gt; nodes;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: Performance</h1>
<p>Say we have V nodes and E edges.

</p>
<p>What is the performance for these operations?

</p>
<ul>
<li>Add vertex</li>
<li>Add edge</li>
<li>Remove vertex</li>
<li>Remove edge</li>
</ul>
<p>Depends on implementation, but this is something you look up.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: Searching</h1>
<p>Problem: Given a node, can we reach this other node?

</p>
<p>Search!
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: Depth First Search (DFS)</h1>
<pre><code class="objectivec"><span class="keyword">bool</span> search(Node root, Node dest) {
  <span class="keyword">if</span> (root<span class="variable">.value</span> == dest<span class="variable">.value</span>)
    <span class="keyword">return</span> <span class="literal">true</span>;
  root<span class="variable">.visited</span> = <span class="literal">true</span>;
  <span class="keyword">for</span> (Node n : root<span class="variable">.adjacent</span>) {
    <span class="keyword">if</span> (!n<span class="variable">.visited</span>) {
      <span class="keyword">if</span> (search(n, dest))
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: Breadth First Search (BFS)</h1>
<pre><code class="objectivec"><span class="keyword">bool</span> search(Node root, Node dest) {
  Queue q = new Queue();
  <span class="keyword">if</span> (root<span class="variable">.value</span> == dest<span class="variable">.value</span>)
    <span class="keyword">return</span> <span class="literal">true</span>;
  root<span class="variable">.visited</span> = <span class="literal">true</span>;
  q<span class="variable">.enqueue</span>(root);
  <span class="keyword">while</span> (!q<span class="variable">.isEmpty</span>()) {
    Node r = q<span class="variable">.dequeue</span>();
    <span class="keyword">for</span> (Node n in r<span class="variable">.adjacent</span>) {
      <span class="keyword">if</span> (!n<span class="variable">.visited</span>) {
        <span class="keyword">if</span> (search(n, dest))
          <span class="keyword">return</span> <span class="literal">true</span>;
        queue<span class="variable">.enqueue</span>(n);
      }
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Graphs: More</h1>
<p>Interesting Graph Problems (wiki):

</p>
<ul>
<li>Djikstra's</li>
<li>Floyd-Warshall</li>
<li>Ford-Fulkerson</li>
<li>Kruskal's</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting</h1>
<p>The problem: given an array containing many values, permute the array so that
those values are in order.

</p>
<p>You'll definitely be expected to have a high-level understanding of these and
know the runtimes. Maybe you'll have to implement one.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting</h1>
<h2>A common tool: swapping</h2>
<pre><code class="cpp"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j) {
    <span class="keyword">int</span> tmp = <span class="built_in">array</span>[i];
    <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];
    <span class="built_in">array</span>[j] = tmp;
}</code></pre>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Selection Sort</h1>
<p><img src="./Data Structures for Interviews_files/Selection-Sort-Animation.gif" alt="Selection Numbers">

</p>
<p>Basically, find the minimum element n times.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Selection Sort</h1>
<pre><code class="cpp"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> selectionSort(<span class="keyword">int</span> <span class="built_in">array</span>[]) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) {
        <span class="keyword">int</span> minIndex = i;
        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">array</span>.length; j++) {
            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[minIndex]) {
                minIndex = j;
            }
        }
        swap(<span class="built_in">array</span>, i, minIndex);
    }
}</code></pre>
<p>General Information

</p>
<ul>
<li>O(n^2) performance</li>
<li>O(1) space</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Bubble Sort</h1>
<p><img src="./Data Structures for Interviews_files/Bubble-sort-example-300px.gif" alt="Bubble Numbers">

</p>
<p>The maximum elements bubble to the top 
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Bubble Sort</h1>
<pre><code class="cpp"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> bubbleSort(<span class="keyword">int</span> <span class="built_in">array</span>[]) {
     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.length - <span class="number">1</span>; j++) {
            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) {
                swap(<span class="built_in">array</span>, j, j + <span class="number">1</span>);
            }
        }
     }
 }</code></pre>
<p>General information

</p>
<ul>
<li>O(n^2) performance</li>
<li>O(1) space</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Merge sort</h1>
<p><img src="./Data Structures for Interviews_files/Merge-sort-example-300px.gif" alt="Merge Numbers">

</p>
<ol>
<li>Split the array in half and sort each subarray.</li>
<li>Weave the arrays back together in one fluid pass.</li>
</ol>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Merge sort</h1>
<p>Here's where I'm going to stop implementing things and just explain them.
Wikipedia is great.

</p>
<p>Merge sort is recursive.

</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">(A)</span>:
    <span class="title">split</span> <span class="title">A</span> <span class="title">into</span> <span class="title">A_beginning</span> <span class="title">and</span> <span class="title">A_end</span> <span class="title">at</span> <span class="title">the</span> <span class="title">middle</span>
    <span class="title">mergeSort</span><span class="params">(A_beginning)</span>
    <span class="title">mergeSort</span><span class="params">(A_end)</span>
    <span class="title">return</span> <span class="title">merge</span><span class="params">(A_beginning, A_end)</span></span></code></pre>
<p>General Information

</p>
<ul>
<li>O(n log n) performance</li>
<li>O(n) space</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Quicksort</h1>
<p><img src="./Data Structures for Interviews_files/Quicksort-example.gif" alt="Quicksort Numbers">

</p>
<p>"Divide and Conquer"
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Quicksort</h1>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">(A)</span>:
    <span class="title">pick</span> <span class="title">a</span> "<span class="title">pivot</span>" <span class="title">element</span> <span class="title">in</span> <span class="title">A</span>
    <span class="title">move</span> <span class="title">all</span> <span class="title">elements</span> <span class="title">less</span> <span class="title">than</span> <span class="title">the</span> <span class="title">pivot</span> <span class="title">to</span> <span class="title">the</span> <span class="title">beginning</span> <span class="title">of</span> <span class="title">A</span>
    <span class="title">move</span> <span class="title">all</span> <span class="title">elements</span> <span class="title">greater</span> <span class="title">than</span> <span class="title">the</span> <span class="title">pivot</span> <span class="title">to</span> <span class="title">the</span> <span class="title">end</span> <span class="title">of</span> <span class="title">A</span>
    <span class="title">put</span> <span class="title">the</span> <span class="title">pivot</span> <span class="title">in</span> <span class="title">the</span> <span class="title">middle</span>
    <span class="title">quicksort</span> <span class="title">the</span> <span class="title">beginning</span> <span class="title">of</span> <span class="title">A</span> <span class="title">recursively</span>
    <span class="title">quicksort</span> <span class="title">the</span> <span class="title">end</span> <span class="title">of</span> <span class="title">A</span> <span class="title">recursively</span></span></code></pre>
<p>General Information

</p>
<ul>
<li>O(n log n) performance</li>
<li>Absolute worst case O(n^2) performance</li>
</ul>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: Counting sort</h1>
<p>Comparison-based sorts can't be faster than n * log(n). BUT non-comparison based
ones can. There are catches, though.

</p>
<pre><code class="cpp"><span class="keyword">public</span> <span class="keyword">void</span> countingSort(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> max) {
    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) {
        counts[<span class="built_in">array</span>[i] - <span class="number">1</span>]++;
    }
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; max; j++) {
        <span class="keyword">while</span> (counts[j] &gt; <span class="number">0</span>) {
            <span class="built_in">array</span>[i++] = j + <span class="number">1</span>;
        }
    }
}</code></pre>
<p>This is a prime example of how NOT to implement a hash map.
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: In General</h1>
<p>Anything slower than O(n^2) is not okay.

</p>
<p>O(n^2) sorting algorithms are generally simpler, easier to code, and require less auxillary space

</p>
<p>O(n log n) is the best comparison based sorting algorithm performance you can get (proven mathematically). These, however, tend to be more complicated and require more memory.

</p>
<p>Faster than O(n log n) sorting sorting usually makes at least one huge assumption about our data set (e.g. counting sort)
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: An Interview Question</h1>
<p>You are given an unsorted array of size n. However, you are also told that where each element is in the unsorted array right now is at most k-1 positions away from its final correctly sorted position. You are told that 1 &lt; k &lt; n.

</p>
<p>What is the best sorting strategy and what is our performance?
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Sorting: An Interview Question</h1>
<p>Solution (in Python):

</p>
<pre><code class="python"><span class="keyword">import</span> heapq

<span class="function"><span class="keyword">def</span> <span class="title">better_sort</span><span class="params">(array, k)</span>:</span>
    final_array = []
    heap = []
    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(k):
        heapq.heappush(heap, array[x])
    index = k
    <span class="keyword">while</span> heap:
        final_array.append(heapq.heappop(heap))
        <span class="keyword">if</span> index &lt; len(array):
            heapq.heappush(heap, array[index])
            index += <span class="number">1</span>
    <span class="keyword">return</span> final_array</code></pre>
<p>Performance: O(n log k)
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Other things to know:</h1>
<ul>
<li><p>How to code in your interview language</p>
</li>
<li><p>How to use Unix (scripting, regexes)</p>
</li>
<li><p>How a computer works (bits and bytes)</p>
</li>
<li><p>Object-oriented programming</p>
</li>
</ul>
</div></div><div class="slide" style="display: table;"><div class="content"><h1>Sample Interview Questions</h1>
<p><a href="https://github.com/adicu/interview_help">https://github.com/adicu/interview_help</a>
</p>
</div></div><div class="slide" style="display: none;"><div class="content"><h1>Other resources</h1>
<ul>
<li><p>Cracking the Coding Interview</p>
</li>
<li><p>Google / Wikipedia</p>
</li>
<li><p>ICPC</p>
</li>
<li><p>CLRS</p>
</li>
<li><p><a href="https://adicu.com/resources">https://adicu.com/resources</a></p>
</li>
</ul>
<p><img src="./Data Structures for Interviews_files/logo.png" alt="ADI">

</p>
</div></div><div class="position">82 / 83</div><div class="overlay light-keys"><div class="content help">
  <h1>Help</h1>
  <p><b>Keyboard shortcuts</b></p>
  <table class="light-keys">
    <tbody><tr>
      <td>
        <kbd>↑</kbd>,
        <kbd>←</kbd>,
        <kbd>pg up</kbd>,
        <kbd>k</kbd>
      </td>
      <td>Go to previous slide</td>
    </tr>
    <tr>
      <td>
        <kbd>↓</kbd>,
        <kbd>→</kbd>,
        <kbd>pg dn</kbd>,
        <kbd>space</kbd>,
        <kbd>j</kbd>
      </td>
      <td>Go to next slide</td>
    </tr>
    <tr>
      <td>
        <kbd>home</kbd> / <kbd>end</kbd>
      </td>
      <td>Go to first / last slide</td>
    </tr>
    <tr>
      <td>
        <kbd>?</kbd>
      </td>
      <td>Show help</td>
    </tr>
  </tbody></table>
</div>
<div class="content dismiss">
  <table class="light-keys">
    <tbody><tr>
      <td>
        <kbd>esc</kbd>
      </td>
      <td>Back to slideshow</td>
    </tr>
  </tbody></table>
</div>
</div></div>
  

</body></html>