<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3013_Final_Exam.fa.19</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <style>
    body {
      line-height: 18px;
      border:5px;
    }

    .break {
      page-break-after: always;
    }

    tr {
      line-height: 10px;
    }

    td{
      padding:3px;
    }
  </style>
</head>

<body class="stackedit">
  <div class="stackedit__html">
    <h2 id="final-exam">3013 - Final Exam</h2>
    <h4 id="name-________________________________">Name ________________________________</h4>

    <h4 id="terminology">Terminology</h4>

    <table>
      <thead>
        <tr>
          <th align="left">Terms</th>
          <th align="left"></th>
          <th align="left"></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left">A. Avalanche</td>
          <td align="left">J. Hash table</td>
          <td align="left">R. Dijkstra’s algorithm</td>
          <td>Z. Digraph</td>
        </tr>
        <tr>
          <td align="left">B. Balanced</td>
          <td align="left">K. Heap</td>
          <td align="left">S. Set</td>
          <td>AA. Set difference</td>
        </tr>
        <tr>
          <td align="left">C. Array</td>
          <td align="left">L. Graph</td>
          <td align="left">T. AVL tree</td>
          <td>BB. Korat</td>
        </tr>
        <tr>
          <td align="left">E. Binary tree</td>
          <td align="left">M. Leaf</td>
          <td align="left">U. Load Factor</td>
          <td>CC. Prim’s algorithm</td>
        </tr>
        <tr>
          <td align="left">F. Binary search tree</td>
          <td align="left">N. Map</td>
          <td align="left">V. Device miniaturization</td>
          <td>DD. Complete</td>
        </tr>
        <tr>
          <td align="left">G. Black box testing</td>
          <td align="left">O. Matrix</td>
          <td align="left">W. Full</td>
          <td>EE. Weighted graph</td>
        </tr>
        <tr>
          <td align="left">H. Breadth First Search</td>
          <td align="left">P. Overflow</td>
          <td align="left">X. Tree</td>
          <td>FF. Root</td>
        </tr>
        <tr>
          <td align="left">I. Collision</td>
          <td align="left">Q. Partially filled array</td>
          <td align="left">Y. Depth First Search</td>
          <td></td>
        </tr>
      </tbody>

      <p><strong>1)</strong> ____ A collection of key-value pairs that associate a key with a value.</p>
      <p><strong>2)</strong> ____ A hierarchical structure that place elements in nodes along branches that originate
        from a root.</p>
      <p><strong>3)</strong> ____ A tree structure in which each node can have at most two children, and in which a
        unique path exists from the root to every other node.</p>
      <p><strong>4)</strong> ____ A type of tree in which the key value of each node is less than every key value in its
        right subtree, and greater than every key value in its left subtree.</p>
      <p><strong>5)</strong> ____ A type of binary tree in which the height of each node’s subtrees differs by no more
        than one.</p>
      <p><strong>6)</strong> ____ A two-dimensional structure that corresponds to a row-column table of entries of a
        specified data type.</p>
      <p><strong>7)</strong> ____ A binary tree in which all of the leaves are on the same level and every non-leaf node
        has exactly two children</p>
      <p><strong>8)</strong> ____ A binary tree that is either full or full through the next-to-last level, with the
        leaves on the last level as far to the left as possible</p>
      <p><strong>9)</strong> ____ A complete binary tree in which each node has a value stored in it that is greater
        than or equal to the value in each of its children.</p>
      <p><strong>10)</strong> ____ Nodes in a binary tree that have only NULL children</p>
      <p><strong>11)</strong> ____ A node in a binary tree that does not have a parent</p>
      <p><strong>12)</strong> ____ A data structure that consists of a set of nodes and a set of edges that relate the
        nodes to each other</p>
      <p><strong>13)</strong> ____ A graph in which each edge is directed from one vertex to another (or the same)
        vertex</p>
      <p><strong>14)</strong> ____ A graph in which every vertex is directly connected to every other vertex</p>
      <p><strong>15)</strong> ____ A graph in which each edge carries a value</p>
      <p><strong>16)</strong> ____ This occurs when 2 different identifiers are hashed into the same location</p>
      <p><strong>17)</strong> ____ A method for finding the shortest path from one vertex to another in a weighted
        digraph</p>
      <p><strong>18)</strong> ____ A graph traversal method that visits the nodes from a starting vertex “level by
        level”</p>
      <p><strong>19)</strong> ____ Extreme change in resulting value by simply changing a single bit.</p>
      <p><strong>20)</strong> As the ________ approaches 1, the number of collisions increases in a hash table.</p>


    </table><img src="https://d3vv6lp55qjaqc.cloudfront.net/items/1Q180P0f3r0X0L0V062B/final_tree.png" width="400px">
    <p><strong>21)</strong> What is the parent of node 5? ___________________<br>
      <strong>22)</strong> What is the height of this tree? ____________________<br>
      <strong>23)</strong> List the children of node 12. ___________________________<br>
      <strong>24)</strong> List all of the non leaf nodes. ______________________________</p>
    <p><strong>25)</strong> Give the order that the nodes are visited in a pre-order traversal of the tree.<br>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.box_row.png" width="700"></p>
    <p><strong>26)</strong> Give the order that the nodes are visited in a in-order traversal of the tree.<br>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.box_row.png" width="700"></p>

      <div class="break"></div>

    <h4 id="multiple-choice">Multiple Choice</h4>
    <p><strong>1)</strong> Insert 70 into the following tree AVL Tree:<br>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.1.png" width=></p>
    <p>Choose the correct result:<br>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.2.ans.png"></p>
    <p><strong>2)</strong> Avl Tree’s:</p>
    <ul>
      <li><strong><code>(A)</code></strong> Always balanced</li>
      <li><strong><code>(B)</code></strong> Perform Double Rotations</li>
      <li><strong><code>(C)</code></strong> Perform single rotations</li>
      <li><strong><code>(D)</code></strong> Maintain a balance factor</li>
      <li><strong><code>(E)</code></strong> All of the above</li>
    </ul>
    <p><strong>3)</strong> Which of the following is true about Huffman Coding?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Prefixes are bounded by the number of occurrences of the most frequent
        letter.</li>
      <li><strong><code>(B)</code></strong> Prefixes are always an alternating pattern of 0’s and 1’s and build upon
        each other.</li>
      <li><strong><code>(C)</code></strong> In Huffman coding, no code is prefix of any other code.</li>
      <li><strong><code>(D)</code></strong> All of the above</li>
    </ul>
    <p><strong>4)</strong> Which of the following is true about Huffman Coding?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Huffman coding is a lossy compression algorithm.</li>
      <li><strong><code>(B)</code></strong> Huffman coding is a lossless compression algorithm.</li>
      <li><strong><code>(C)</code></strong> Huffman coding can be both lossy or lossless depending on the
        implementation.</li>
      <li><strong><code>(D)</code></strong> All of the above</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <div class="break"></div>
    <p><strong>5)</strong> Is this a viable tree for the text ‘mississippi’?</p>
    <ul>
      <li><strong><code>(A)</code></strong> True</li>
      <li><strong><code>(B)</code></strong> False</li>
    </ul>
    <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.answer.3.png" height="200">
    <p><strong>6)</strong> How many bits would be needed to encode ‘mississippi’?</p>
    <ul>
      <li><strong><code>(A)</code></strong> 1</li>
      <li><strong><code>(B)</code></strong> 2</li>
      <li><strong><code>(C)</code></strong> 3</li>
      <li><strong><code>(D)</code></strong> 4</li>
      <li><strong><code>(E)</code></strong> 5</li>
    </ul>
    <p><strong>7)</strong> The linear probe method for hash tables suffers from the phenomenon known as:</p>
    <ul>
      <li><strong><code>(A)</code></strong> fatal collisions</li>
      <li><strong><code>(B)</code></strong> sparse distribution</li>
      <li><strong><code>(C)</code></strong> clustering</li>
      <li><strong><code>(D)</code></strong> broken chains</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>8)</strong> Which of the following are true of heaps ? (choose all that apply)</p>
    <ul>
      <li><strong><code>(A)</code></strong> It is a binary tree</li>
      <li><strong><code>(B)</code></strong> In terms of its shape, it must be complete</li>
      <li><strong><code>(C)</code></strong> It can be either a maximal or a minimal heap</li>
      <li><strong><code>(D)</code></strong> The value of the root has no relationship to the value of any other nodes
      </li>
      <li><strong><code>(E)</code></strong> Is useful for implementing a stack</li>
      <li><strong><code>(F)</code></strong> Is the most efficient representation for a priority queue</li>
    </ul>
    <p><strong>9)</strong> Hashing is an ______ search algorithm.</p>
    <ul>
      <li><strong><code>(A)</code></strong> O(log2n)</li>
      <li><strong><code>(B)</code></strong> O(n2)</li>
      <li><strong><code>(C)</code></strong> O(n)</li>
      <li><strong><code>(D)</code></strong> O(1)</li>
    </ul>
    <div class="break"></div>
    <p><strong>10)</strong> What graph traversal algorithm uses a queue to keep track of vertices which need to be
      processed?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Breadth-first search.</li>
      <li><strong><code>(B)</code></strong> Depth-first search.</li>
    </ul>
    <p><strong>11)</strong> How many spanning trees does the following graph have?</p>
    <center>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.spanning_tree.1.png" width="300">
    </center>
    <ul>
      <li><strong><code>(A)</code></strong> 1</li>
      <li><strong><code>(B)</code></strong> 2</li>
      <li><strong><code>(C)</code></strong> 3</li>
      <li><strong><code>(D)</code></strong> 4</li>
      <li><strong><code>(E)</code></strong> More than 4</li>
    </ul>
    <hr>
    <center>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.kruskels.1.png" width="300"></center>
    <p><strong>12)</strong> In the figure above, using Kruskal’s algorithm, which edge should we choose first?</p>
    <ul>
      <li><strong><code>(A)</code></strong> AB</li>
      <li><strong><code>(B)</code></strong> EG</li>
      <li><strong><code>(C)</code></strong> BE</li>
      <li><strong><code>(D)</code></strong> AG</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>13)</strong> In the figure above, using Kruskal’s algorithm, which edge should we choose third?</p>
    <ul>
      <li><strong><code>(A)</code></strong> EF</li>
      <li><strong><code>(B)</code></strong> AG</li>
      <li><strong><code>(C)</code></strong> BG</li>
      <li><strong><code>(D)</code></strong> EG</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>14)</strong> In the figure above, using Kruskal’s algorithm, which edge should we choose last?</p>
    <ul>
      <li><strong><code>(A)</code></strong> None of the above</li>
      <li><strong><code>(B)</code></strong> AB</li>
      <li><strong><code>(C)</code></strong> AC</li>
      <li><strong><code>(D)</code></strong> CD</li>
      <li><strong><code>(E)</code></strong> BC</li>
    </ul>
    <p><strong>15)</strong> In the figure above, which of the following edges of the given graph are not part of
      Kruskel’s MST?</p>
    <ul>
      <li><strong><code>(A)</code></strong> AC</li>
      <li><strong><code>(B)</code></strong> EF</li>
      <li><strong><code>(C)</code></strong> AG</li>
      <li><strong><code>(D)</code></strong> BG</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>16)</strong> In the figure above, the total weight of the MST is:</p>
    <ul>
      <li><strong><code>(A)</code></strong> 31.</li>
      <li><strong><code>(B)</code></strong> 42.</li>
      <li><strong><code>(C)</code></strong> 55.</li>
      <li><strong><code>(D)</code></strong> 95.</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>17)</strong> Which of the following statements is true about Kruskal’s algorithm (choose one):</p>
    <ul>
      <li><strong><code>(A)</code></strong> It is an inefficient algorithm, and it never gives the minimum spanning
        tree.</li>
      <li><strong><code>(B)</code></strong> It is an efficient algorithm, and it always gives the minimum spanning tree.
      </li>
      <li><strong><code>(C)</code></strong> It is an efficient algorithm, but it doesn’t always give the minimum
        spanning tree.</li>
      <li><strong><code>(D)</code></strong> It is an inefficient algorithm, but it always gives the minimum spanning
        tree.</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>18)</strong> <code>True</code> or <code>False</code>: Prim’s algorithm is a greedy algorithm but
      Kruskal’s algorithm is not.</p>
    <hr>
    <center>Prims Questions<br>
      <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.prims_graph_2.png" width="300"></center>
    <p><strong>19)</strong> In the figure above, using Prim’s algorithm, which edge should we choose first? The starting
      node is A.</p>
    <ul>
      <li><strong><code>(A)</code></strong> GE</li>
      <li><strong><code>(B)</code></strong> GF</li>
      <li><strong><code>(C)</code></strong> CB</li>
      <li><strong><code>(D)</code></strong> AF</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>20)</strong> In the figure above, using Prim’s algorithm, which edge should we choose third?</p>
    <ul>
      <li><strong><code>(A)</code></strong> DF</li>
      <li><strong><code>(B)</code></strong> AG</li>
      <li><strong><code>(C)</code></strong> BG</li>
      <li><strong><code>(D)</code></strong> EG</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>21)</strong> In the figure above, using Prim’s algorithm, which edge should we choose last?</p>
    <ul>
      <li><strong><code>(A)</code></strong> GE</li>
      <li><strong><code>(B)</code></strong> AF</li>
      <li><strong><code>(C)</code></strong> BC</li>
      <li><strong><code>(D)</code></strong> DC</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>22)</strong> In the figure above, which of the following edges of the given graph are not part of the
      minimum spanning tree?</p>
    <ul>
      <li><strong><code>(A)</code></strong> CB</li>
      <li><strong><code>(B)</code></strong> BG</li>
      <li><strong><code>(C)</code></strong> CD</li>
      <li><strong><code>(D)</code></strong> AC</li>
      <li><strong><code>(E)</code></strong> All of the above</li>
    </ul>
    <p><strong>23)</strong> In the figure above, the total weight of the minimum spanning tree is</p>
    <ul>
      <li><strong><code>(A)</code></strong> 25.</li>
      <li><strong><code>(B)</code></strong> 21.</li>
      <li><strong><code>(C)</code></strong> 22.</li>
      <li><strong><code>(D)</code></strong> 23.</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <hr>
    <p><strong>24)</strong> Suppose we run Dijkstra’s single source shortest-path algorithm on the following edge
      weighted directed graph with vertex P as the source. In what order do the nodes get included into the set of
      vertices for which the shortest path distances are finalized?</p>
    <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.1.gif">
    <ul>
      <li><strong><code>(A)</code></strong> P, Q, R, S, T, U</li>
      <li><strong><code>(B)</code></strong> P, Q, R, U, S, T</li>
      <li><strong><code>(C)</code></strong> P, Q, R, U, T, S</li>
      <li><strong><code>(D)</code></strong> P, Q, T, R, U, S</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>25)</strong> Dijkstra’s single source shortest path algorithm when run from vertex a in the below graph,
      computes the correct shortest path distance to:</p>
    <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.2.gif">
    <ul>
      <li><strong><code>(A)</code></strong> Only vertex A</li>
      <li><strong><code>(B)</code></strong> Only vertices a, e, f, g, h</li>
      <li><strong><code>(C)</code></strong> Only vertices a, b, c, d</li>
      <li><strong><code>(D)</code></strong> All the vertices</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>26)</strong> Consider the directed graph shown in the figure below. There are multiple shortest paths
      between vertices S and T. Which one will be reported by Dijstra?s shortest path algorithm? Assume that, in any
      iteration, the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered.</p>
    <img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.3.png" width="400">
    <ul>
      <li><strong><code>(A)</code></strong> SDT</li>
      <li><strong><code>(B)</code></strong> SBDT</li>
      <li><strong><code>(C)</code></strong> SACDT</li>
      <li><strong><code>(D)</code></strong> SACET</li>
      <li>None of the above</li>
    </ul>
    <p><strong>27)</strong> In a weighted graph, assume that the shortest path from a source ‘s’ to a destination ‘t’ is
      correctly calculated using a shortest path algorithm. Is the following statement true? <em><strong>If we increase
          weight of every edge by 1, the shortest path always remains same.</strong></em></p>
    <ul>
      <li><strong><code>(A)</code></strong> True</li>
      <li><strong><code>(B)</code></strong> False</li>
      <li></li>
    </ul>
    <p><strong>28)</strong> Is the following statement valid?<br>
      <em><strong>Given a weighted graph where weights of all edges are unique (no two edge have same weights), there is
          always a single unique shortest path from a source to destination in such a graph.</strong></em></p>
    <ul>
      <li><strong><code>(A)</code></strong> True</li>
      <li><strong><code>(B)</code></strong> False</li>
      <li></li>
    </ul>
    <p><strong>29)</strong> Let <em><strong><code>G(V, E)</code></strong></em> an undirected graph with positive edge
      weights. Dijkstra’s single-source shortest path algorithm can be implemented using the <strong>binary
        heap</strong> data structure with time complexity:</p>
    <ul>
      <li><strong><code>(A)</code></strong> <code>O(|V|^2)</code></li>
      <li><strong><code>(B)</code></strong> <code>O (|E| + |V| log |V|)</code></li>
      <li><strong><code>(C)</code></strong> <code>O (|V| log |V|)</code></li>
      <li><strong><code>(D)</code></strong> <code>O ((|E| + |V|) log |V|)</code></li>
      <li><strong><code>(E)</code></strong> None of the above</li>
      <li></li>
    </ul>
    <hr>
    <center>A-Star</center>
    <p><strong>30)</strong> The A-Star algorithm:</p>
    <ul>
      <li><strong><code>(A)</code></strong> Doesn’t always find the shortest path</li>
      <li><strong><code>(B)</code></strong> Is based on Dijkstra’s algorithm</li>
      <li><strong><code>(C)</code></strong> Relies on a heuristics to make choices</li>
      <li><strong><code>(D)</code></strong> All of the above</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>31)</strong> The cost function in A-Star is calculated where cost = <code>g() + h()</code> where:</p>
    <ul>
      <li><strong><code>(A)</code></strong> <code>g()</code> = distance_from_start , <code>h()</code> =
        distance_to_target</li>
      <li><strong><code>(B)</code></strong> <code>g()</code> = total_cost , <code>h()</code> = current_cost</li>
      <li><strong><code>(C)</code></strong> <code>g()</code> = current_cost , <code>h()</code> = total_cost</li>
      <li><strong><code>(D)</code></strong> <code>g()</code> = a-star_cost, <code>h()</code> = dijkstras_cost</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>32)</strong> Which of the following data structures requires more than constant average time for
      insertions? (choose all that apply)</p>
    <ul>
      <li><strong><code>(A)</code></strong> hash table</li>
      <li><strong><code>(B)</code></strong> queue</li>
      <li><strong><code>(C)</code></strong> search tree</li>
      <li><strong><code>(D)</code></strong> stack</li>
      <li><strong><code>(E)</code></strong> all of the above have constant time insertion algorithms</li>
    </ul>
    <p><strong>33)</strong> What is the range of values computed by the hash function:<br>
      <code>Hash(X) = X mod 100</code>?</p>
    <ul>
      <li><strong><code>(A)</code></strong> 0 to 99</li>
      <li><strong><code>(B)</code></strong> 0 to 100</li>
      <li><strong><code>(C)</code></strong> 1 to 99</li>
      <li><strong><code>(D)</code></strong> 1 to 100 14</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>34)</strong> Which of A to D is false:<br>
      The size of a hash table:</p>
    <ul>
      <li><strong><code>(A)</code></strong> should be a power of 2 for quadratic probing</li>
      <li><strong><code>(B)</code></strong> should be a prime number for linear probing</li>
      <li><strong><code>(C)</code></strong> should be about 2<sup>n</sup> for quadratic probing</li>
      <li><strong><code>(D)</code></strong> should be about n for separate chaining</li>
      <li><strong><code>(E)</code></strong> if you mark this one, you will get it right (seriously color in E).</li>
    </ul>
    <p><strong>35)</strong> How are elements deleted in linear probing?</p>
    <ul>
      <li><strong><code>(A)</code></strong> deletion is not allowed</li>
      <li><strong><code>(B)</code></strong> they are remove and changed to zero</li>
      <li><strong><code>(C)</code></strong> they are removed and marked deleted</li>
      <li><strong><code>(D)</code></strong> they are removed then run unchecked deallocation</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>36)</strong> Suppose we are implementing quadratic probing with a hash function:<br>
      <code>Hash(X) = X mod 100</code> where the probe sequence is: <img
        src="https://wikimedia.org/api/rest_v1/media/math/render/svg/40ae2a97f9cdcc56936d0af6166125512db20019"
        alt="H+1{2},H+2{2},H+3{2},H+4{2},...,H+k^{2}">.<br>
      If an element with key 4594 is inserted and the first three locations attempted are already occupied, then the
      next cell that will be tried is:</p>
    <ul>
      <li><strong><code>(A)</code></strong> 2</li>
      <li><strong><code>(B)</code></strong> 3</li>
      <li><strong><code>(C)</code></strong> 10</li>
      <li><strong><code>(D)</code></strong> 97</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>37)</strong> In a separate chaining hash table with load factor = 0.8, what is the average length of a
      list?</p>
    <ul>
      <li><strong><code>(A)</code></strong> 0.8</li>
      <li><strong><code>(B)</code></strong> 1.0</li>
      <li><strong><code>(C)</code></strong> 1.25</li>
      <li><strong><code>(D)</code></strong> there is not enough information</li>
      <li><strong><code>(E)</code></strong> there is enough information, but none of the above are correct</li>
    </ul>
    <p><strong>38)</strong> Which of the following costs are equal in a probing hash table?</p>
    <ul>
      <li><strong><code>(A)</code></strong> insertion and successful search</li>
      <li><strong><code>(B)</code></strong> insertion and unsuccessful search</li>
      <li><strong><code>(C)</code></strong> successful search and unsuccessful search</li>
      <li><strong><code>(D)</code></strong> insertion, successful search, and unsuccessful search</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>39)</strong> Linked lists are used in:</p>
    <ul>
      <li><strong><code>(A)</code></strong> double hashing</li>
      <li><strong><code>(B)</code></strong> linear probing</li>
      <li><strong><code>(C)</code></strong> quadratic probing</li>
      <li><strong><code>(D)</code></strong> separate chaining</li>
      <li><strong><code>(E)</code></strong> all of the above</li>
    </ul>
    <p><strong>40)</strong> Primary clustering occurs in</p>
    <ul>
      <li><strong><code>(A)</code></strong> linear probing</li>
      <li><strong><code>(B)</code></strong> quadratic probing</li>
      <li><strong><code>(C)</code></strong> separate chaining</li>
      <li><strong><code>(D)</code></strong> all of the above</li>
      <li><strong><code>(E)</code></strong> none of A, B, and C</li>
    </ul>
    <p><strong>41)</strong> Every node in a (<strong>min</strong>) binary heap</p>
    <ul>
      <li><strong><code>(A)</code></strong> has two children</li>
      <li><strong><code>(B)</code></strong> is larger than its children</li>
      <li><strong><code>(C)</code></strong> is smaller than its children</li>
      <li><strong><code>(D)</code></strong> has a smaller left child than right child</li>
      <li><strong><code>(E)</code></strong> two or more of the above</li>
    </ul>
    <p><strong>42)</strong> If an element in a binary heap is stored in position i and the root is at position 1, then
      where is the parent stored?</p>
    <ul>
      <li><strong><code>(A)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mo stretchy="false">⌈</mo>
                    <mrow>
                      <mi>i</mi>
                      <mi mathvariant="normal">/</mi>
                      <mn>2</mn>
                    </mrow>
                    <mo stretchy="false">⌉</mo>
                  </mrow>
                  <annotation encoding="application/x-tex">\lceil{i/2}\rceil</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌈</span><span
                  class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span
                    class="mord">2</span></span><span class="mclose">⌉</span></span></span></span></span></li>
      <li><strong><code>(B)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mo stretchy="false">⌊</mo>
                    <mrow>
                      <mi>i</mi>
                      <mi mathvariant="normal">/</mi>
                      <mn>2</mn>
                    </mrow>
                    <mo stretchy="false">⌋</mo>
                  </mrow>
                  <annotation encoding="application/x-tex">\lfloor{i/2}\rfloor</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span
                  class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span
                    class="mord">2</span></span><span class="mclose">⌋</span></span></span></span></span></li>
      <li><strong><code>(C)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mn>1</mn>
                    <mo>+</mo>
                    <mo stretchy="false">⌊</mo>
                    <mrow>
                      <mi>i</mi>
                      <mi mathvariant="normal">/</mi>
                      <mn>2</mn>
                    </mrow>
                    <mo stretchy="false">⌋</mo>
                  </mrow>
                  <annotation encoding="application/x-tex">1 + \lfloor{i/2}\rfloor</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span
                  class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span
                  class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut"
                  style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span
                  class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span
                    class="mord">2</span></span><span class="mclose">⌋</span></span></span></span></span></li>
      <li><strong><code>(D)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mn>2</mn>
                    <mo>∗</mo>
                    <mi>i</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">2*i</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mspace"
                  style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace"
                  style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut"
                  style="height: 0.65952em; vertical-align: 0em;"></span><span
                  class="mord mathdefault">i</span></span></span></span></span></li>
      <li><strong><code>(E)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mn>2</mn>
                    <mi>i</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                  <annotation encoding="application/x-tex">2i + 1</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span
                  class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span
                  class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span
                  class="mord">1</span></span></span></span></span></li>
    </ul>
    <p><strong>43)</strong> The running time of Build Heap is</p>
    <ul>
      <li><strong><code>(A)</code></strong> <code>O(n)</code> worst case and <code>O(n)</code> average case</li>
      <li><strong><code>(B)</code></strong> <code>O(n)</code> worst case and <code>O(log n)</code> average case</li>
      <li><strong><code>(C)</code></strong> <code>O(n)</code> worst case and <code>O(n log n)</code> average case</li>
      <li><strong><code>(D)</code></strong> <code>O(n log n)</code> worst case and <code>O(n)</code> average case</li>
      <li><strong><code>(E)</code></strong> <code>O(n log n)</code> worst case and <code>O(n log n)</code> average case
      </li>
    </ul>
    <p><strong>44)</strong> <strong>n</strong> elements are inserted one by one into an initially empty <strong>binary
        heap</strong>. The total running time is:</p>
    <ul>
      <li><strong><code>(A)</code></strong> <code>O(n)</code> worst case and <code>O(n)</code> average case</li>
      <li><strong><code>(B)</code></strong> <code>O(n)</code> worst case and <code>O(log n)</code> average case</li>
      <li><strong><code>(C)</code></strong> <code>O(n)</code> worst case and <code>O(n log n)</code> average case</li>
      <li><strong><code>(D)</code></strong> <code>O(n log n)</code> worst case and <code>O(n)</code> average case</li>
      <li><strong><code>(E)</code></strong> <code>O(n log n)</code> worst case and <code>O(n log n)</code> average case
      </li>
    </ul>
    <p><strong>45)</strong> Which operation is not supported in constant time by a linked list with a head and tail
      pointer?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Insertion as the front or rear item</li>
      <li><strong><code>(B)</code></strong> Access of the front or rear item</li>
      <li><strong><code>(C)</code></strong> Deletion of the front or rear item</li>
      <li><strong><code>(D)</code></strong> Access and deletion of the minimum item</li>
      <li><strong><code>(E)</code></strong> all of the above are supported</li>
    </ul>
    <p><strong>46)</strong> Which operation in a min heap cannot be done in at least <span class="katex--inline"><span
          class="katex"><span class="katex-mathml"><math>
              <semantics>
                <mrow>
                  <mi>O</mi>
                  <mo stretchy="false">(</mo>
                  <mi>l</mi>
                  <mi>g</mi>
                  <mi>N</mi>
                  <mo stretchy="false">)</mo>
                </mrow>
                <annotation encoding="application/x-tex">O(lg N)</annotation>
              </semantics>
            </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault"
                style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault"
                style="margin-right: 0.01968em;">l</span><span class="mord mathdefault"
                style="margin-right: 0.03588em;">g</span><span class="mord mathdefault"
                style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>
      (efficient) time?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Delete Min</li>
      <li><strong><code>(B)</code></strong> Find</li>
      <li><strong><code>(C)</code></strong> Find Min</li>
      <li><strong><code>(D)</code></strong> Insert</li>
      <li><strong><code>(E)</code></strong> All of the above are efficiently supported</li>
    </ul>
    <p><strong>47)</strong> Which data structure is best used to check for balanced parentheses?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Priority queue</li>
      <li><strong><code>(D)</code></strong> Queue</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>48)</strong> Jobs sent to a printer are generally placed on a:</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Priority queue</li>
      <li><strong><code>(D)</code></strong> Queue</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>49)</strong> Which data structure is generally used to implement a symbol table (table that has a string
      that points to an address)?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Priority queue</li>
      <li><strong><code>(D)</code></strong> Queue</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>50)</strong> Which of the following could be used as an efficient <strong>priority queue</strong>?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Linked list</li>
      <li><strong><code>(D)</code></strong> Array</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>51)</strong> Which of the following does the <strong>binary heap</strong> implement?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Priority queue</li>
      <li><strong><code>(D)</code></strong> Queue</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>52)</strong> 6, 8, 4, 3, and 1 are inserted into a data structure in that order. An item is deleted using
      only a basic data structure operation. If the deleted item is a 1, the data structure cannot be a:</p>
    <ul>
      <li><strong><code>(A)</code></strong> Hash table</li>
      <li><strong><code>(B)</code></strong> Priority queue</li>
      <li><strong><code>(C)</code></strong> Queue</li>
      <li><strong><code>(D)</code></strong> Search tree</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>53)</strong> Which data structure is used by the compiler to implement recursion?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Hash table</li>
      <li><strong><code>(B)</code></strong> Priority queue</li>
      <li><strong><code>(C)</code></strong> Queue</li>
      <li><strong><code>(D)</code></strong> Search tree</li>
      <li><strong><code>(E)</code></strong> Stack</li>
    </ul>
    <p><strong>54)</strong> Which of the following data structures uses a sentinel value (sentinel = flag)?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary heap</li>
      <li><strong><code>(B)</code></strong> Hash table</li>
      <li><strong><code>(C)</code></strong> Queue</li>
      <li><strong><code>(D)</code></strong> Stack</li>
      <li><strong><code>(E)</code></strong> None of the above use sentinels</li>
    </ul>
    <p><strong>55)</strong> A node with key 8 has a left child with key 10. Which of the following objects could this
      node be found in?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Binary search tree</li>
      <li><strong><code>(B)</code></strong> Max heap</li>
      <li><strong><code>(C)</code></strong> Min heap</li>
      <li><strong><code>(D)</code></strong> Two of the above</li>
      <li><strong><code>(E)</code></strong> None of A, B, and C</li>
    </ul>
    <p><strong>56)</strong> Bubble up and down are used for</p>
    <ul>
      <li><strong><code>(A)</code></strong> AVL trees</li>
      <li><strong><code>(B)</code></strong> B-trees</li>
      <li><strong><code>(C)</code></strong> Circular queue</li>
      <li><strong><code>(D)</code></strong> Binary heaps</li>
      <li><strong><code>(E)</code></strong> None of the above</li>
    </ul>
    <p><strong>57)</strong> Which of the following is a synonym for an edge?</p>
    <ul>
      <li><strong><code>(A)</code></strong> arc</li>
      <li><strong><code>(B)</code></strong> node</li>
      <li><strong><code>(C)</code></strong> path</li>
      <li><strong><code>(D)</code></strong> vertex</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>58)</strong> Which of the following does not use a queue?</p>
    <ul>
      <li><strong><code>(A)</code></strong> negative weighted shortest path algorithm</li>
      <li><strong><code>(B)</code></strong> positive weighted shortest path algorithm</li>
      <li><strong><code>(C)</code></strong> topological sort</li>
      <li><strong><code>(D)</code></strong> unweighted shortest path algorithm</li>
      <li><strong><code>(E)</code></strong> all of the above use a queue</li>
    </ul>
    <p><strong>59)</strong> Which of the following algorithms solves the unweighted single source shortest path problem?
    </p>
    <ul>
      <li><strong><code>(A)</code></strong> breadth first search</li>
      <li><strong><code>(B)</code></strong> depth first search</li>
      <li><strong><code>(C)</code></strong> Dijkstra’s algorithm</li>
      <li><strong><code>(D)</code></strong> Kruskal’s algorithm</li>
      <li><strong><code>(E)</code></strong> Prim’s algorithm</li>
    </ul>
    <p><strong>60)</strong> Which of the following algorithms solves the positive weighted single source shortest path
      problem?</p>
    <ul>
      <li><strong><code>(A)</code></strong> breadth first search</li>
      <li><strong><code>(B)</code></strong> depth first search</li>
      <li><strong><code>(C)</code></strong> Dijkstra’s algorithm</li>
      <li><strong><code>(D)</code></strong> Kruskal’s algorithm</li>
      <li><strong><code>(E)</code></strong> Prim’s algorithm</li>
    </ul>
    <p><strong>61)</strong> If the shortest path algorithm is run and a vertex is not reachable from the starting point,
      what happens?</p>
    <ul>
      <li><strong><code>(A)</code></strong> a distance of infinity is reported</li>
      <li><strong><code>(B)</code></strong> a distance of -1 is reported</li>
      <li><strong><code>(C)</code></strong> a distance of zero is reported</li>
      <li><strong><code>(D)</code></strong> the algorithm enters an infinite loop</li>
      <li><strong><code>(E)</code></strong> the algorithm’s results are undefined</li>
    </ul>
    <img src="https://www.lucidchart.com/publicSegments/view/d9366ca4-7836-49dc-83f9-406c5b356140/image.jpeg"
      width="350">
    <p><strong>62)</strong> The shortest weighted path from V4 to V5 has weight:</p>
    <ul>
      <li><strong><code>(A)</code></strong> 2</li>
      <li><strong><code>(B)</code></strong> 4</li>
      <li><strong><code>(C)</code></strong> 7</li>
      <li><strong><code>(D)</code></strong> 8</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>63)</strong> If the start vertex is V4, then using Dijkstra’s shortest path algorithm, which is the last
      vertex to be declared known?</p>
    <ul>
      <li><strong><code>(A)</code></strong> V0</li>
      <li><strong><code>(B)</code></strong> V1</li>
      <li><strong><code>(C)</code></strong> V2</li>
      <li><strong><code>(D)</code></strong> V4</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>64)</strong> If the above graph were undirected, then what would be the cost of its minimum spanning
      tree?</p>
    <ul>
      <li><strong><code>(A)</code></strong> 1</li>
      <li><strong><code>(B)</code></strong> 10</li>
      <li><strong><code>(C)</code></strong> 11</li>
      <li><strong><code>(D)</code></strong> 12</li>
      <li><strong><code>(E)</code></strong> none of the above</li>
    </ul>
    <p><strong>65)</strong> Which algorithm is used to compute minimum spanning trees?</p>
    <ul>
      <li><strong><code>(A)</code></strong> breadth first search</li>
      <li><strong><code>(B)</code></strong> depth first search</li>
      <li><strong><code>(C)</code></strong> Dijkstra’s</li>
      <li><strong><code>(D)</code></strong> Kruskal’s</li>
      <li><strong><code>(E)</code></strong> Bellman Ford</li>
    </ul>
    <p><strong>66)</strong> What is the worst-case search time for finding a single item in an array?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Constant time</li>
      <li><strong><code>(B)</code></strong> Logarithmic time</li>
      <li><strong><code>(C)</code></strong> Linear time</li>
      <li><strong><code>(D)</code></strong> Quadratic time</li>
      <li><strong><code>(E)</code></strong> Awesome time</li>
    </ul>
    <p><strong>67)</strong> What is the worst-case time for binary search finding a single item in an array?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Constant time</li>
      <li><strong><code>(B)</code></strong> Logarithmic time</li>
      <li><strong><code>(C)</code></strong> Linear time</li>
      <li><strong><code>(D)</code></strong> Quadratic time</li>
      <li><strong><code>(E)</code></strong> Not possible in an Array</li>
    </ul>
    <p><strong>68)</strong> What is the worst-case time for binary search finding a single item in a doubly linked list?
    </p>
    <ul>
      <li><strong><code>(A)</code></strong> Constant time</li>
      <li><strong><code>(B)</code></strong> Logarithmic time</li>
      <li><strong><code>(C)</code></strong> Linear time</li>
      <li><strong><code>(D)</code></strong> Quadratic time</li>
      <li><strong><code>(E)</code></strong> Not possible in a List</li>
    </ul>
    <p><strong>69)</strong> What additional requirement is placed on an array, so that binary search may be used to
      locate an entry?</p>
    <ul>
      <li><strong><code>(A)</code></strong> The array elements must form a heap.</li>
      <li><strong><code>(B)</code></strong> The array must have at least 2 entries.</li>
      <li><strong><code>(C)</code></strong> The array must be sorted.</li>
      <li><strong><code>(D)</code></strong> The array’s size must be a power of two.</li>
    </ul>
    <p><strong>70)</strong> What is the best definition of a collision in a hash table?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Two entries are identical except for their keys.</li>
      <li><strong><code>(B)</code></strong> Two entries with different data have the exact same key.</li>
      <li><strong><code>(C)</code></strong> Two entries with different keys have the same exact hash value.</li>
      <li><strong><code>(D)</code></strong> Two entries with the exact same key have different hash values.</li>
    </ul>
    <p><strong>71)</strong> Which guideline is NOT suggested from from empirical or theoretical studies of hash tables:
    </p>
    <ul>
      <li><strong><code>(A)</code></strong> Hash table size should be the product of two primes.</li>
      <li><strong><code>(B)</code></strong> Hash table size should be the upper of a pair of twin primes.</li>
      <li><strong><code>(C)</code></strong> Hash table size should be a factor of 2 , 5, or 10.</li>
      <li><strong><code>(D)</code></strong> Hash table size should not be too near a power of two.</li>
      <li><strong><code>(E)</code></strong> C and D should be avoided.</li>
    </ul>
    <p><strong>72)</strong> What kind of initialization needs to be done for an open-address hash table?</p>
    <ul>
      <li><strong><code>(A)</code></strong> None.</li>
      <li><strong><code>(B)</code></strong> The key at each array location must be initialized.</li>
      <li><strong><code>(C)</code></strong> The head pointer of each chain must be set to NULL.</li>
      <li><strong><code>(D)</code></strong> Both B and C must be carried out.</li>
    </ul>
    <p><strong>73)</strong> What kind of initialization needs to be done for an chained hash table?</p>
    <ul>
      <li><strong><code>(A)</code></strong> None.</li>
      <li><strong><code>(B)</code></strong> The key at each array location must be initialized.</li>
      <li><strong><code>(C)</code></strong> The head pointer of each chain must be set to NULL.</li>
      <li><strong><code>(D)</code></strong> Both B and C must be carried out.</li>
    </ul>
    <p><strong>74)</strong> A chained hash table has an array size of 512. What is the maximum number of entries that
      can be placed in the table?</p>
    <ul>
      <li><strong><code>(A)</code></strong> 256</li>
      <li><strong><code>(B)</code></strong> 511</li>
      <li><strong><code>(C)</code></strong> 512</li>
      <li><strong><code>(D)</code></strong> 1024</li>
      <li><strong><code>(E)</code></strong> There is no maximum.</li>
    </ul>
    <p><strong>75)</strong> Suppose you place m items in a hash table with an array size of s. What is the correct
      formula for the load factor?</p>
    <ul>
      <li><strong><code>(A)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mi>s</mi>
                    <mo>+</mo>
                    <mi>m</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">s + m</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.66666em; vertical-align: -0.08333em;"></span><span
                  class="mord mathdefault">s</span><span class="mspace" style="margin-right: 0.222222em;"></span><span
                  class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span
                  class="mord mathdefault">m</span></span></span></span></span></li>
      <li><strong><code>(B)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mi>s</mi>
                    <mo>−</mo>
                    <mi>m</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">s - m</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.66666em; vertical-align: -0.08333em;"></span><span
                  class="mord mathdefault">s</span><span class="mspace" style="margin-right: 0.222222em;"></span><span
                  class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span
                  class="mord mathdefault">m</span></span></span></span></span></li>
      <li><strong><code>(C)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mi>m</mi>
                    <mo>−</mo>
                    <mi>s</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">m - s</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.66666em; vertical-align: -0.08333em;"></span><span
                  class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span
                  class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span
                  class="mord mathdefault">s</span></span></span></span></span></li>
      <li><strong><code>(D)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mi>m</mi>
                    <mo>∗</mo>
                    <mi>s</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">m * s</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 0.46528em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span
                  class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span
                  class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut"
                  style="height: 0.43056em; vertical-align: 0em;"></span><span
                  class="mord mathdefault">s</span></span></span></span></span></li>
      <li><strong><code>(E)</code></strong> <span class="katex--inline"><span class="katex"><span
              class="katex-mathml"><math>
                <semantics>
                  <mrow>
                    <mi>m</mi>
                    <mi mathvariant="normal">/</mi>
                    <mi>s</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">m / s</annotation>
                </semantics>
              </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                  style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span
                  class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></li>
    </ul>
    <p><strong>76)</strong> <strong>T / F</strong>: I can sort items in an array of numbers simply by inserting them
      into a binary tree and then removing the items 1 at a time from the root.</p>
    <p><strong>77)</strong> Which of the following is not a hash function that we discussed in class?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Rotating hash</li>
      <li><strong><code>(B)</code></strong> Bernstein hash</li>
      <li><strong><code>(C)</code></strong> Modified Einstein hash</li>
      <li><strong><code>(D)</code></strong> Shift-Add-XOR hash</li>
      <li><strong><code>(E)</code></strong> Elf Hash</li>
    </ul>
    <p><strong>78)</strong> Huffman coding can be used for:</p>
    <ul>
      <li><strong><code>(A)</code></strong> Simple Text Compression</li>
      <li><strong><code>(B)</code></strong> Filtering</li>
      <li><strong><code>(C)</code></strong> Checksums / CRC Checks</li>
      <li><strong><code>(D)</code></strong> Error Correction</li>
      <li><strong><code>(E)</code></strong> Check-hashbin Compression</li>
    </ul>
    <p><strong>79)</strong> Which algorithm is more greedy?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Prim’s</li>
      <li><strong><code>(B)</code></strong> Kruskel’s</li>
      <li><strong><code>(C)</code></strong> Dijkstra’s</li>
      <li><strong><code>(D)</code></strong> They’re all greedy</li>
      <li><strong><code>(E)</code></strong> None are greedy</li>
    </ul>
    <p><strong>80)</strong> What is your expected grade in this class?</p>
    <ul>
      <li><strong><code>(A)</code></strong> A</li>
      <li><strong><code>(B)</code></strong> B</li>
      <li><strong><code>(C)</code></strong> C</li>
      <li><strong><code>(D)</code></strong> D</li>
      <li><strong><code>(E)</code></strong> F</li>
    </ul>
    <p><strong>81)</strong> Is it the same as when you started the semester?</p>
    <ul>
      <li><strong><code>(A)</code></strong> Yes</li>
      <li><strong><code>(B)</code></strong> No, I did worse than expected.</li>
      <li><strong><code>(C)</code></strong> No, I did better than expected.</li>
    </ul>
  </div>
</body>

</html>