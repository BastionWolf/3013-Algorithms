
  
#### Multiple Choice

__1)__ Insert 70 into the following tree AVL Tree:
<img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.1.png">  

Choose the correct result:
<img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.2.ans.png">  

__2)__ Avl Tree's:

- __`(A)`__ Always balanced
- __`(B)`__ Perform Double Rotations
- __`(C)`__ Perform single rotations
- __`(D)`__ Maintain a balance factor
- __`(E)`__ All of the above

__3)__ Which of the following is true about Huffman Coding?  
- __`(A)`__ Prefixes are bounded by the number of occurrences of the most frequent letter.  
- __`(B)`__ Prefixes are always an alternating pattern of 0's and 1's and build upon each other.
- __`(C)`__ In Huffman coding, no code is prefix of any other code.  
- __`(D)`__ All of the above

__4)__ Which of the following is true about Huffman Coding?  
- __`(A)`__ Huffman coding is a lossy compression algorithm. 
- __`(B)`__ Huffman coding is a lossless compression algorithm.
- __`(C)`__ Huffman coding can be both lossy or lossless depending on the implementation.   
- __`(D)`__ All of the above
- __`(E)`__ None of the above

__5)__ Is this a viable tree for the text ‘mississippi’? 

- __`(A)`__  True
- __`(B)`__ False

<img src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.avl.answer.3.png" height="200">  

__6)__ How many bits would be needed to encode ‘mississippi’?
- __`(A)`__ 1
- __`(B)`__ 2
- __`(C)`__ 3
- __`(D)`__ 4
- __`(E)`__ 5

__7)__ The linear probe method for hash tables suffers from the phenomenon known as:

- __`(A)`__ fatal collisions
- __`(B)`__ sparse distribution
- __`(C)`__ clustering
- __`(D)`__ broken chains
- __`(E)`__ none of the above
  
__8)__ Which of the following are true of heaps ? (choose all that apply)
  
- __`(A)`__ It is a binary tree
- __`(B)`__ In terms of its shape, it must be complete
- __`(C)`__ It can be either a maximal or a minimal heap
- __`(D)`__ The value of the root has no relationship to the value of any other nodes
- __`(E)`__ Is useful for implementing a stack
__F)__ Is the most efficient representation for a priority queue
  
__9)__ Hashing is an ______ search algorithm.

- __`(A)`__ O(log2n)
- __`(B)`__ O(n2)
- __`(C)`__ O(n)
- __`(D)`__ O(1)
  
  
__10)__ What graph traversal algorithm uses a queue to keep track of vertices which need to be processed?
  
- __`(A)`__ Breadth-first search.
- __`(B)`__ Depth-first search.
  

__11)__ How many spanning trees does the following graph have?
<center>
<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.spanning_tree.1.png"  width="300"></center>

- __`(A)`__ 1
- __`(B)`__ 2
- __`(C)`__ 3
- __`(D)`__ 4
- __`(E)`__ More than 4

 ---
 <center>
<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.kruskels.1.png"  width="300"></center>
  
__12)__ In the figure above, using Kruskal's algorithm, which edge should we choose first?
- __`(A)`__ AB
- __`(B)`__ EG
- __`(C)`__ BE
- __`(D)`__ AG
- __`(E)`__ None of the above
  
__13)__ In the figure above, using Kruskal's algorithm, which edge should we choose third?
- __`(A)`__ EF
- __`(B)`__ AG
- __`(C)`__ BG
- __`(D)`__ EG
- __`(E)`__ None of the above
  
__14)__ In the figure above, using Kruskal's algorithm, which edge should we choose last?
- __`(A)`__ None of the above
- __`(B)`__ AB
- __`(C)`__ AC
- __`(D)`__ CD
- __`(E)`__ BC
  
__15)__ In the figure above, which of the following edges of the given graph are not part of Kruskel's MST?
- __`(A)`__ AC
- __`(B)`__ EF
- __`(C)`__ AG
- __`(D)`__ BG
- __`(E)`__ None of the above
  
__10)__ In the figure above, the total weight of the MST is:
- __`(A)`__ 31.
- __`(B)`__ 42.
- __`(C)`__ 55.
- __`(D)`__ 95.
- __`(E)`__ None of the above
  
__11)__ Which of the following statements is true about Kruskal's algorithm (choose one):

- __`(A)`__ It is an inefficient algorithm, and it never gives the minimum spanning tree.
- __`(B)`__ It is an efficient algorithm, and it always gives the minimum spanning tree.
- __`(C)`__ It is an efficient algorithm, but it doesn't always give the minimum spanning tree.
- __`(D)`__ It is an inefficient algorithm, but it always gives the minimum spanning tree.
- __`(E)`__ None of the above
  
__12)__  `True` or `False`: Prim’s algorithm is a greedy algorithm but Kruskal’s algorithm is not.
 
  ---
 <center>Prims Questions<br>
<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.prims_graph_2.png"  width="300"></center>
 
 
__13)__ In the figure above, using Prim's algorithm, which edge should we choose first? The starting node is A.
- __`(A)`__ GE
- __`(B)`__ GF
- __`(C)`__ CB
- __`(D)`__ AF
- __`(E)`__ None of the above
  
__14)__ In the figure above, using Prim's algorithm, which edge should we choose third?
- __`(A)`__ DF
- __`(B)`__ AG
- __`(C)`__ BG
- __`(D)`__ EG
- __`(E)`__ None of the above
  
__15)__ In the figure above, using Prim's algorithm, which edge should we choose last?
- __`(A)`__ GE
- __`(B)`__ AF
- __`(C)`__ BC
- __`(D)`__ DC
- __`(E)`__ None of the above
  
__16)__ In the figure above, which of the following edges of the given graph are not part of the minimum spanning tree?
- __`(A)`__ CB
- __`(B)`__ BG
- __`(C)`__ CD
- __`(D)`__ AC
- __`(E)`__ All of the above
  
__17)__ In the figure above, the total weight of the minimum spanning tree is
- __`(A)`__ 25.
- __`(B)`__ 21.
- __`(C)`__ 22.
- __`(D)`__ 23.
- __`(E)`__ None of the above
---

__X)__ Suppose we run Dijkstra’s single source shortest-path algorithm on the following edge weighted directed graph with vertex P as the source. In what order do the nodes get included into the set of vertices for which the shortest path distances are finalized?

<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.1.gif">

- __`(A)`__ P, Q, R, S, T, U
- __`(B)`__ P, Q, R, U, S, T 
- __`(C)`__ P, Q, R, U, T, S
- __`(D)`__ P, Q, T, R, U, S
- __`(E)`__ None of the above

__X)__ Dijkstra’s single source shortest path algorithm when run from vertex a in the below graph, computes the correct shortest path distance to:

<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.2.gif">

- __`(A)`__ Only vertex A
- __`(B)`__ Only vertices a, e, f, g, h 
- __`(C)`__ Only vertices a, b, c, d
- __`(D)`__ All the vertices
- __`(E)`__ None of the above

__X)__ Consider the directed graph shown in the figure below. There are multiple shortest paths between vertices S and T. Which one will be reported by Dijstra?s shortest path algorithm? Assume that, in any iteration, the shortest path to a vertex v is updated only when a strictly shorter path to v is discovered.

<img  src="https://cs.msutexas.edu/~griffin/zcloud/zcloud-files/3013.final.dijkstras.3.png" width="400">

- __`(A)`__ SDT
- __`(B)`__ SBDT
- __`(C)`__ SACDT
- __`(D)`__ SACET
- None of the above

__X)__  In a weighted graph, assume that the shortest path from a source 's' to a destination 't' is correctly calculated using a shortest path algorithm. Is the following statement true? __*If we increase weight of every edge by 1, the shortest path always remains same.__*

- __`(A)`__ True
- __`(B)`__ False
- 
__X)__  Is the following statement valid? 
  __*Given a weighted graph where weights of all edges are unique (no two edge have same weights), there is always a single unique shortest path from a source to destination in such a graph.__*
  
- __`(A)`__ True
- __`(B)`__ False
- 
__X)__  Let __*`G(V, E)`__* an undirected graph with positive edge weights. Dijkstra's single-source shortest path algorithm can be implemented using the __binary heap__ data structure with time complexity:

- __`(A)`__ `O(|V|^2)`
- __`(B)`__ `O (|E| + |V| log |V|)`
- __`(C)`__ `O (|V| log |V|)`
- __`(D)`__ `O ((|E| + |V|) log |V|)`
- __`(E)`__ None of the above
- 
---
<center>A-Star</center>

__X)__ The A-Star algorithm:
- __`(A)`__ Doesn't always find the shortest path
- __`(B)`__ Is based on Dijkstra's algorithm 
- __`(C)`__ Relies on a heuristics to make choices
- __`(D)`__ All of the above
- __`(E)`__ None of the above

__X)__ The cost function in A-Star is calculated where cost = `g() + h()` where:

- __`(A)`__ `g()` = distance_from_start ,  `h()` = distance_to_target
- __`(B)`__ `g()` = total_cost ,  `h()` = current_cost
- __`(C)`__ `g()` = current_cost ,  `h()` = total_cost
- __`(D)`__ `g()` = a-star_cost,  `h()` = dijkstras_cost
- __`(E)`__ None of the above


__18)__ Which of the following data structures requires more than constant average time for insertions? (choose all that apply)

- __`(A)`__ hash table
- __`(B)`__ queue
- __`(C)`__ search tree
- __`(D)`__ stack
- __`(E)`__ all of the above have constant time insertion algorithms
  
__19)__ What is the range of values computed by the hash function:
`Hash(X) = X mod 100`?

- __`(A)`__ 0 to 99
- __`(B)`__ 0 to 100
- __`(C)`__ 1 to 99
- __`(D)`__ 1 to 100 14
- __`(E)`__ none of the above
  
__20)__ Which of A to D is false:
The size of a hash table:

- __`(A)`__ should be a power of 2 for quadratic probing
- __`(B)`__ should be a prime number for linear probing
- __`(C)`__ should be about 2<sup>n</sup> for quadratic probing
- __`(D)`__ should be about n for separate chaining
- __`(E)`__ if you mark this one, you will get it right (seriously color in E).
  
__21)__ How are elements deleted in linear probing?

- __`(A)`__ deletion is not allowed
- __`(B)`__ they are remove and changed to zero
- __`(C)`__ they are removed and marked deleted
- __`(D)`__ they are removed then run unchecked deallocation
- __`(E)`__ none of the above
  
__22)__ Suppose we are implementing quadratic probing with a hash function:
`Hash(X) = X mod 100` where the probe sequence is: ![H+1^{2},H+2^{2},H+3^{2},H+4^{2},...,H+k^{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/40ae2a97f9cdcc56936d0af6166125512db20019).
If an element with key 4594 is inserted and the first three locations attempted are already occupied, then the next cell that will be tried is:
- __`(A)`__ 2
- __`(B)`__ 3
- __`(C)`__ 10
- __`(D)`__ 97
- __`(E)`__ none of the above
  
__23)__ In a separate chaining hash table with load factor = 0.8, what is the average length of a list?
- __`(A)`__ 0.8
- __`(B)`__ 1.0
- __`(C)`__ 1.25
- __`(D)`__ there is not enough information
- __`(E)`__ there is enough information, but none of the above are correct
  
__24)__ Which of the following costs are equal in a probing hash table?

- __`(A)`__ insertion and successful search
- __`(B)`__ insertion and unsuccessful search
- __`(C)`__ successful search and unsuccessful search
- __`(D)`__ insertion, successful search, and unsuccessful search
- __`(E)`__ none of the above
  
  
__26)__ Linked lists are used in:

- __`(A)`__ double hashing
- __`(B)`__ linear probing
- __`(C)`__ quadratic probing
- __`(D)`__ separate chaining
- __`(E)`__ all of the above
  
__27)__ Primary clustering occurs in
- __`(A)`__ linear probing
- __`(B)`__ quadratic probing
- __`(C)`__ separate chaining
- __`(D)`__ all of the above
- __`(E)`__ none of A, B, and C
  

__29)__ Every node in a (__min__) binary heap
- __`(A)`__ has two children
- __`(B)`__ is larger than its children
- __`(C)`__ is smaller than its children
- __`(D)`__ has a smaller left child than right child
- __`(E)`__ two or more of the above 
  
__30)__ If an element in a binary heap is stored in position i and the root is at position 1, then where is the parent stored?
- __`(A)`__ $\lceil{i/2}\rceil$
- __`(B)`__ $\lfloor{i/2}\rfloor$
- __`(C)`__ $1 + \lfloor{i/2}\rfloor$
- __`(D)`__ $2*i$
- __`(E)`__ $2i + 1$
  
__31)__ The running time of Build Heap is
- __`(A)`__  `O(n)` worst case and `O(n)` average case
- __`(B)`__  `O(n)` worst case and `O(log n)` average case
- __`(C)`__  `O(n)` worst case and `O(n log n)` average case
- __`(D)`__  `O(n log n)` worst case and `O(n)` average case
- __`(E)`__  `O(n log n)` worst case and `O(n log n)` average case
  
__32)__ __n__ elements are inserted one by one into an initially empty __binary heap__. The total running time is:

- __`(A)`__  `O(n)` worst case and `O(n)` average case
- __`(B)`__  `O(n)` worst case and `O(log n)` average case
- __`(C)`__  `O(n)` worst case and `O(n log n)` average case
- __`(D)`__  `O(n log n)` worst case and `O(n)` average case
- __`(E)`__  `O(n log n)` worst case and `O(n log n)` average case
  
__33)__ Which operation is not supported in constant time by a linked list with a head and tail pointer?

- __`(A)`__ Insertion as the front or rear item
- __`(B)`__ Access of the front or rear item
- __`(C)`__ Deletion of the front or rear item
- __`(D)`__ Access and deletion of the minimum item
- __`(E)`__ all of the above are supported
  
__34)__ Which operation in a min heap cannot be done in at least $O(lg N)$ (efficient) time?

- __`(A)`__ Delete Min
- __`(B)`__ Find
- __`(C)`__ Find Min
- __`(D)`__ Insert
- __`(E)`__ All of the above are efficiently supported
  
__35)__ Which data structure is best used to check for balanced parentheses?
- __`(A)`__ Binary search tree
- __`(B)`__ Hash table
- __`(C)`__ Priority queue
- __`(D)`__ Queue
- __`(E)`__ Stack
  
__36)__ Jobs sent to a printer are generally placed on a:
- __`(A)`__ Binary search tree
- __`(B)`__ Hash table
- __`(C)`__ Priority queue
- __`(D)`__ Queue
- __`(E)`__ Stack
  
__37)__ Which data structure is generally used to implement a symbol table (table that has a string that points to an address)?
- __`(A)`__ Binary search tree
- __`(B)`__ Hash table
- __`(C)`__ Priority queue
- __`(D)`__ Queue
- __`(E)`__ Stack
  
__38)__ Which of the following could be used as an efficient __priority queue__?

- __`(A)`__ Binary search tree
- __`(B)`__ Hash table
- __`(C)`__ Linked list
- __`(D)`__ Array
- __`(E)`__ Stack
  
__39)__ Which of the following does the __binary heap__ implement?

- __`(A)`__ Binary search tree
- __`(B)`__ Hash table
- __`(C)`__ Priority queue
- __`(D)`__ Queue
- __`(E)`__ Stack
  
__40)__ 6, 8, 4, 3, and 1 are inserted into a data structure in that order. An item is deleted using only a basic data structure operation. If the deleted item is a 1, the data structure cannot be a:

- __`(A)`__ Hash table
- __`(B)`__ Priority queue
- __`(C)`__ Queue
- __`(D)`__ Search tree
- __`(E)`__ Stack
  
__41)__ Which data structure is used by the compiler to implement recursion?

- __`(A)`__ Hash table
- __`(B)`__ Priority queue
- __`(C)`__ Queue
- __`(D)`__ Search tree
- __`(E)`__ Stack
  
__42)__ Which of the following data structures uses a sentinel value (sentinel = flag)?

- __`(A)`__ Binary heap
- __`(B)`__ Hash table
- __`(C)`__ Queue
- __`(D)`__ Stack
- __`(E)`__ None of the above use sentinels
  
__43)__ A node with key 8 has a left child with key 10. Which of the following objects could this node be found in?

- __`(A)`__ Binary search tree
- __`(B)`__ Max heap
- __`(C)`__ Min heap
- __`(D)`__ Two of the above
- __`(E)`__ None of A, B, and C
  
__44)__ Bubble up and down are used for

- __`(A)`__ AVL trees
- __`(B)`__ B-trees
- __`(C)`__ Circular queue
- __`(D)`__ Binary heaps
- __`(E)`__ None of the above
  
__45)__ Which of the following is a synonym for an edge?

- __`(A)`__ arc
- __`(B)`__ node
- __`(C)`__ path
- __`(D)`__ vertex
- __`(E)`__ none of the above
  
__46)__ Which of the following does not use a queue?

- __`(A)`__ negative weighted shortest path algorithm
- __`(B)`__ positive weighted shortest path algorithm
- __`(C)`__ topological sort
- __`(D)`__ unweighted shortest path algorithm
- __`(E)`__ all of the above use a queue
  
__47)__ Which of the following algorithms solves the unweighted single source shortest path problem?

- __`(A)`__ breadth first search
- __`(B)`__ depth first search
- __`(C)`__ Dijkstra's algorithm
- __`(D)`__ Kruskal's algorithm
- __`(E)`__ Prim's algorithm
  
__48)__ Which of the following algorithms solves the positive weighted single source shortest path problem?

- __`(A)`__ breadth first search
- __`(B)`__ depth first search
- __`(C)`__ Dijkstra's algorithm
- __`(D)`__ Kruskal's algorithm
- __`(E)`__ Prim's algorithm
  
__49)__ If the shortest path algorithm is run and a vertex is not reachable from the starting point, what happens?
  
- __`(A)`__ a distance of infinity is reported
- __`(B)`__ a distance of -1 is reported
- __`(C)`__ a distance of zero is reported
- __`(D)`__ the algorithm enters an infinite loop
- __`(E)`__ the algorithm's results are undefined
  
<img  src="https://www.lucidchart.com/publicSegments/view/d9366ca4-7836-49dc-83f9-406c5b356140/image.jpeg"  width="350">
  
__50)__ The shortest weighted path from V4 to V5 has weight:

- __`(A)`__ 2
- __`(B)`__ 4
- __`(C)`__ 7
- __`(D)`__ 8
- __`(E)`__ none of the above
  
__51)__ If the start vertex is V4, then using Dijkstra's shortest path algorithm, which is the last vertex to be declared known?

- __`(A)`__ V0
- __`(B)`__ V1
- __`(C)`__ V2
- __`(D)`__ V4
- __`(E)`__ none of the above
  
__52)__ If the above graph were undirected, then what would be the cost of its minimum spanning tree?

- __`(A)`__ 1
- __`(B)`__ 10
- __`(C)`__ 11
- __`(D)`__ 12
- __`(E)`__ none of the above
  
__53)__ Which algorithm is used to compute minimum spanning trees?

- __`(A)`__ breadth first search
- __`(B)`__ depth first search
- __`(C)`__ Dijkstra's
- __`(D)`__ Kruskal's
- __`(E)`__ Bellman Ford
  
__54)__ What is the worst-case search time for finding a single item in an array?

- __`(A)`__ Constant time
- __`(B)`__ Logarithmic time
- __`(C)`__ Linear time
- __`(D)`__ Quadratic time
- __`(E)`__ Awesome time
  
__55)__ What is the worst-case time for binary search finding a single item in an array?

- __`(A)`__ Constant time
- __`(B)`__ Logarithmic time
- __`(C)`__ Linear time
- __`(D)`__ Quadratic time
- __`(E)`__ Not possible in an Array

__55)__ What is the worst-case time for binary search finding a single item in a doubly linked list?

- __`(A)`__ Constant time
- __`(B)`__ Logarithmic time
- __`(C)`__ Linear time
- __`(D)`__ Quadratic time 
- __`(E)`__ Not possible in a List
 
__56)__ What additional requirement is placed on an array, so that binary search may be used to locate an entry?

- __`(A)`__ The array elements must form a heap.
- __`(B)`__ The array must have at least 2 entries.
- __`(C)`__ The array must be sorted.
- __`(D)`__ The array's size must be a power of two.
  
__57)__ What is the best definition of a collision in a hash table?

- __`(A)`__ Two entries are identical except for their keys.
- __`(B)`__ Two entries with different data have the exact same key.
- __`(C)`__ Two entries with different keys have the same exact hash value.
- __`(D)`__ Two entries with the exact same key have different hash values.
  
__58)__ Which guideline is NOT suggested from from empirical or theoretical studies of hash tables:

- __`(A)`__ Hash table size should be the product of two primes.
- __`(B)`__ Hash table size should be the upper of a pair of twin primes.
- __`(C)`__ Hash table size should be a factor of 2 , 5, or 10.
- __`(D)`__ Hash table size should not be too near a power of two.
- __`(E)`__ C and D should be avoided.
  
__59)__ What kind of initialization needs to be done for an open-address hash table?

- __`(A)`__ None.
- __`(B)`__ The key at each array location must be initialized.
- __`(C)`__ The head pointer of each chain must be set to NULL.
- __`(D)`__ Both B and C must be carried out.
  
__60)__ What kind of initialization needs to be done for an chained hash table?

- __`(A)`__ None.
- __`(B)`__ The key at each array location must be initialized.
- __`(C)`__ The head pointer of each chain must be set to NULL.
- __`(D)`__ Both B and C must be carried out.
  
__61)__ A chained hash table has an array size of 512. What is the maximum number of entries that can be placed in the table?

- __`(A)`__ 256
- __`(B)`__ 511
- __`(C)`__ 512
- __`(D)`__ 1024
- __`(E)`__ There is no maximum.
  
__62)__ Suppose you place m items in a hash table with an array size of s. What is the correct formula for the load factor?

- __`(A)`__ $s + m$
- __`(B)`__ $s - m$
- __`(C)`__ $m - s$
- __`(D)`__ $m * s$
- __`(E)`__ $m / s$

__63)__ __T / F__: I can sort items in an array of numbers simply by inserting them into a binary tree and then removing the items 1 at a time from the root.

__64)__ Which of the following is not a hash function that we discussed in class?

- __`(A)`__ Rotating hash
- __`(B)`__ Bernstein hash
- __`(C)`__ Modified Einstein hash
- __`(D)`__ Shift-Add-XOR hash
- __`(E)`__ Elf Hash

__65)__ Huffman coding can be used for:

- __`(A)`__ Simple Text Compression
- __`(B)`__ Filtering
- __`(C)`__ Checksums / CRC Checks
- __`(D)`__ Error Correction
- __`(E)`__  Check-hashbin Compression

__66)__ Which algorithm is more greedy?

- __`(A)`__ Prim's
- __`(B)`__ Kruskel's
- __`(C)`__ Dijkstra's
- __`(D)`__ They're all greedy
- __`(E)`__  None are greedy




